"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[1590,7945],{47549:(e,t,i)=>{i.d(t,{jX:()=>h,zo:()=>f,gd:()=>d,ph:()=>o,no:()=>m,kz:()=>u,ht:()=>c,yo:()=>p});var r=i(39960);class n{constructor(e=15e3,t=5e3){this._timer=null,this._cachedBlocks=new Map,this._size=-1,this._duration=e,this._interval=Math.min(e,t)}decreaseRefCount(e,t){let i=e+"/"+t,r=this._cachedBlocks;if(r.has(i)){let e=r.get(i);return e.refCount--,e.refCount<=0&&(r.delete(i),e.controller&&e.controller.abort()),e.refCount}return 0}getBlock(e,t){let i=e+"/"+t,r=this._cachedBlocks;if(r.has(i)){let e=r.get(i);return e.ts=Date.now(),e.refCount++,r.delete(i),r.set(i,e),e.block}return null}putBlock(e,t,i,r){let n=this._cachedBlocks,s=e+"/"+t;if(n.has(s)){let e=n.get(s);e.ts=Date.now(),e.refCount++}else n.set(s,{block:i,ts:Date.now(),refCount:1,controller:r});this._trim(),this._updateTimer()}deleteBlock(e,t){let i=this._cachedBlocks,r=e+"/"+t;i.has(r)&&i.delete(r)}updateMaxSize(e){this._size=e,this._trim()}empty(){this._cachedBlocks.clear(),this._clearTimer()}getCurrentSize(){return this._cachedBlocks.size}_updateTimer(){if(null!=this._timer)return;let e=this._cachedBlocks;this._timer=setInterval(()=>{let t=Array.from(e),i=Date.now();for(let r=0;r<t.length&&t[r][1].ts<=i-this._duration;r++)e.delete(t[r][0]);0===e.size&&this._clearTimer()},this._interval)}_trim(){let e=this._cachedBlocks;if(-1===this._size||this._size>=e.size)return;let t=Array.from(e);for(let i=0;i<t.length-this._size;i++)e.delete(t[i][0])}_clearTimer(){null!=this._timer&&(clearInterval(this._timer),this._timer=null)}}var s=i(34455);let l=new Map,a=new n;function o(e,t){return null==t?e:`${e}?sliceId=${t}`}function u(e,t){let i={extent:null,rasterInfo:t,cache:new Map},r=l.get(e);return r?(r.push(i),r.length-1):(l.set(e,[i]),0)}function c(e,t){let i=l.get(e);i&&(i[t]=null,i.some(e=>null!=e)||l.delete(e))}function h(e,t,i){let r=l.get(e);if(!r)return null==t?a.decreaseRefCount(e,i):0;if(null==t||null==r[t])return a.decreaseRefCount(e,i);let n=r[t]?.cache,s=n?.get(i);if(n&&s){if(s.refCount--,0===s.refCount){n.delete(i);for(let e=0;e<r.length;e++)r[e]?.cache.delete(i);s.controller&&s.controller.abort()}return s.refCount}return 0}function d(e,t,i){let r=l.get(e);if(!r)return null==t?a.getBlock(e,i):null;if(null==t||null==r[t]){for(let e=0;e<r.length;e++){let t=r[e]?.cache.get(i);if(t)return t.refCount++,t.block}return a.getBlock(e,i)}let n=r[t]?.cache.get(i);if(n)return n.refCount++,n.block;for(let e=0;e<r.length;e++){if(e===t||!r[e])continue;let n=r[e]?.cache,s=n?.get(i);if(n&&s)return s.refCount++,n.set(i,s),s.block}return null}function m(e,t,i,r,n=null){let s=l.get(e);if(!s)return void(null==t&&a.putBlock(e,i,r,n));if(null==t||null==s[t])return void a.putBlock(e,i,r,n);let o={refCount:1,block:r,isResolved:!1,isRejected:!1,controller:n};r.then(()=>o.isResolved=!0).catch(()=>o.isRejected=!0),s[t]?.cache.set(i,o)}function f(e,t,i){let r=l.get(e);r?null!=t&&null!=r[t]?r[t]?.cache.delete(i):a.deleteBlock(e,i):null==t&&a.deleteBlock(e,i)}function p(e,t,i,n,a,o,u=null){let c=function(e,t){let i=l.get(e);return i?i[t]??null:null}(e,t);if(!c)return;let h=c.extent,{cache:d,rasterInfo:m}=c;if(h&&h.xmin===i.xmin&&h.xmax===i.xmax&&h.ymin===i.ymin&&h.ymax===i.ymax)return;n=n??0;let f=i.clone().normalize(),{spatialReference:y,transform:g}=m,x=new Set;for(let e=0;e<f.length;e++){let t=f[e];if(t.xmax-t.xmin<=n||t.ymax-t.ymin<=n)continue;let i=(0,s._l)(t,y,u);null!=g&&(i=g.inverseTransform(i));let l=new r.A({x:n,y:n,spatialReference:t.spatialReference});if(null==a&&!(a=(0,s.Wo)(l,y,t,u)))return;let{pyramidLevel:c,pyramidResolution:h,excessiveReading:d}=(0,s.t$)(a,m,o||"closest");if(d)return;let{storageInfo:p}=m,{origin:_}=p,{x:b,y:R}=h,I=Math.max(0,Math.floor((i.xmin-_.x)/b)),w=Math.max(0,Math.floor((_.y-i.ymax)/R)),v=Math.ceil(i.width/b-.1),S=Math.ceil(i.height/R-.1),k=c>0?p.pyramidBlockWidth:p.blockWidth,M=c>0?p.pyramidBlockHeight:p.blockHeight,T=p.blockBoundary[c];if(!T)continue;let F=Math.max(T.minCol,Math.floor(I/k)-1),P=Math.max(T.minRow,Math.floor(w/M)-1),C=Math.min(T.maxCol,Math.floor((I+v-1)/k)+1),J=Math.min(T.maxRow,Math.floor((w+S-1)/M)+1);for(let e=P;e<=J;e++)for(let t=F;t<=C;t++)x.add(`${c}/${e}/${t}`)}d.forEach((e,t)=>{if(!x.has(t)){let e=d.get(t);(null==e||e.isResolved||e.isRejected)&&d.delete(t)}}),c.extent={xmin:i.xmin,ymin:i.ymin,xmax:i.xmax,ymax:i.ymax}}},48298:(e,t,i)=>{function r(e,t){if(!e||!t)return[];let i=t;t.includes("/")?(i=t.slice(0,t.indexOf("/")),t=t.slice(t.indexOf("/")+1)):t="";let n=[];if(t){let s=r(e,i);for(let e=0;e<s.length;e++)r(s[e],t).forEach(e=>n.push(e));return n}let s=e.getElementsByTagNameNS("*",i);if(!s||0===s.length)return[];for(let e=0;e<s.length;e++)n.push(s[e]||s.item(e));return n}function n(e,t){if(!e||!t)return null;let i=t;t.includes("/")?(i=t.slice(0,t.indexOf("/")),t=t.slice(t.indexOf("/")+1)):t="";let s=r(e,i);return s.length>0?t?n(s[0],t):s[0]:null}function s(e,t=null){let i,r=t?n(e,t):e;return r&&(i=r.textContent||r.nodeValue)?i.trim():null}function l(e,t){let i,n=r(e,t),s=[];for(let e=0;e<n.length;e++)(i=n[e].textContent||n[e].nodeValue)&&""!==(i=i.trim())&&s.push(i);return s}function a(e,t=null){let i=s(e,t);return i?.split(" ").map(e=>Number(e))??[]}function o(e,t){return l(e,t).map(e=>Number(e))}function u(e,t){return Number(s(e,t))}function c(e,t){let i=e?.nodeName?.toLowerCase(),r=t.toLowerCase();return i.slice(i.lastIndexOf(":")+1)===r}function h(e){return e.nodeName.slice(e.nodeName.lastIndexOf(":")+1)}i.d(t,{Dy:()=>l,IC:()=>r,Ui:()=>o,V6:()=>n,g7:()=>c,mX:()=>s,pN:()=>a,v7:()=>u,vv:()=>h})},61590:(e,t,i)=>{i.d(t,{QueueProcessor:()=>c});var r=i(40941),n=i(92753),s=i(27298),l=i(69358),a=i(77089),o=i(22303);class u{constructor(e,t){this.item=e,this.controller=t,this.promise=null}}class c{constructor(e){this._schedule=null,this._deferreds=new l.A,this._controllers=new l.A,this._processingItems=new l.A,this._pausedSignal=(0,o.v)(!1),this.concurrency=1,e.concurrency&&(this.concurrency=e.concurrency),this._queue=new s.A(e.peeker),this.process=e.process}destroy(){this.clear(),this._schedule=(0,r.xt)(this._schedule)}get updating(){return this.running}get length(){return this._processingItems.size+this._queue.length}get running(){return!this._pausedSignal.value&&this._queue.length>0&&this._processingItems.size<this.concurrency}abort(e){let t=this._controllers.get(e);t&&t.abort()}clear(){this._queue.clear();let e=[];this._controllers.forEach(t=>e.push(t)),this._controllers.clear(),e.forEach(e=>e.abort()),this._processingItems.clear(),this._cancelNext()}forEach(e){this._deferreds.forEach((t,i)=>e(i))}get(e){let t=this._deferreds.get(e);return t?t.promise:void 0}isOngoing(e){return this._processingItems.has(e)}has(e){return this._deferreds.has(e)}pause(){this._pausedSignal.value||(this._pausedSignal.value=!0,this._cancelNext())}push(e,t){let i=this.get(e);if(i)return i;let r=new AbortController,s=null;t&&(s=(0,n.u7)(t,()=>r.abort()));let l=()=>{a.remove(),null!=s&&s.remove(),this._removeItem(e),this._queue.remove(e),this._scheduleNext()},a=(0,n.NY)(r.signal,()=>{let t=this._processingItems.get(e);t&&t.controller.abort(),l(),o.reject((0,n.NK)())}),o=(0,n.Tw)();return this._deferreds.set(e,o),this._controllers.set(e,r),o.promise.then(l,l),this._queue.push(e),this._scheduleNext(),o.promise}last(){return this._queue.last()}lastPromise(){let e=this.last();return e?this.get(e):null}peek(){return this._queue.peek()}popLast(){let e=this._queue.popLast();return e&&(this._deferreds.get(e)?.reject((0,n.NK)()),this._removeItem(e)),e}reset(){let e=Array.from(this._processingItems.values());for(let t of(this._processingItems.clear(),e))this._queue.push(t.item),t.controller.abort();this._scheduleNext()}resume(){this._pausedSignal.value&&(this._pausedSignal.value=!1,this._scheduleNext())}takeAll(){let e=[];for(;this._queue.length;)e.push(this._queue.pop());return this.clear(),e}_removeItem(e){this._deferreds.delete(e),this._controllers.delete(e),this._processingItems.delete(e)}_scheduleNext(){this._pausedSignal.value||this._schedule||(this._schedule=(0,a._)(()=>{this._schedule=null,this._next()}))}_next(){for(;this._queue.length>0&&this._processingItems.size<this.concurrency;)this._process(this._queue.pop())}_cancelNext(){this._schedule&&(this._schedule.remove(),this._schedule=null)}_processResult(e,t){this._canProcessFulfillment(e)&&(this._scheduleNext(),this._deferreds.get(e.item).resolve(t))}_processError(e,t){this._canProcessFulfillment(e)&&(this._scheduleNext(),this._deferreds.get(e.item).reject(t))}_canProcessFulfillment(e){return!!this._deferreds.get(e.item)&&this._processingItems.get(e.item)===e}_process(e){let t;if(null==e)return;let i=new AbortController,r=new u(e,i);this._processingItems.set(e,r);try{t=this.process(e,i.signal)}catch(e){this._processError(r,e)}(0,n.$X)(t)?(r.promise=t,t.then(e=>this._processResult(r,e),e=>this._processError(r,e))):this._processResult(r,t)}}},72076:(e,t,i)=>{i.d(t,{A:()=>f});var r=i(81856),n=i(32391),s=i(91838);i(57845),i(61939),i(33638);var l=i(12709),a=i(87960),o=i(82245),u=i(18402),c=i(93782),h=i(34455),d=i(49570);let m=class extends o.A{constructor(){super(...arguments),this.datasetFormat="Function",this.tileType="Raster",this.rasterFunction=null,this._clippingGeometry=new Map}async fetchPixels(e,t,i,r={}){let n,{rasters:s,rasterIds:l}=this.primaryRasters,a=!1,{interpolation:o}=r,h=this.rasterFunction.flatWebGLFunctionChain?.hasFocalFunction;!r.requestRawData&&h&&(a=1===s.length&&!r.skipRasterFunction,r={...r,interpolation:"bilinear",requestRawData:a});let d=s.map(n=>n.fetchPixels(e,t,i,r)),m=await Promise.all(d),f=m.map(e=>e.pixelBlock),p=a||r.requestRawData?m.map(e=>e.srcTilePixelSize):null;if(r.skipRasterFunction||f.every(e=>null==e))return m[0];let y=m.find(e=>null!=e.pixelBlock)?.extent??e,g=this.rasterJobHandler?await this.rasterJobHandler.process({extent:y,primaryPixelBlocks:f,primaryPixelSizes:p,primaryRasterIds:l}):this.rasterFunction.process({extent:y,primaryPixelBlocks:f,primaryPixelSizes:p,primaryRasterIds:l}),{transformGrid:x}=m[0];if(!a||null==g||null==x){let e=r.noClip?null:this.getClippingGeometry(y.spatialReference);return r.noClip||r.requestRawData||null==g||!e||(g=await (0,u.$Q)(g,y,e)),{...m[0],pixelBlock:g}}let _={rows:x.spacing[0],cols:x.spacing[1]};n=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:[g],srcMosaicSize:{width:g.width,height:g.height},destDimension:{width:t,height:i},coefs:x.coefficients,sampleSpacing:_,projectDirections:!1,gcsGrid:null,isUV:!1,interpolation:o,alignmentInfo:void 0,blockWidths:null},r)).pixelBlock:(0,c.$i)(g,{width:t,height:i},x.coefficients,_,o);let b=r.noClip?null:this.getClippingGeometry(e.spatialReference);return r.noClip||r.requestRawData||null==n||null==b||(n=await (0,u.$Q)(n,e,b)),{extent:e,srcExtent:m[0].srcExtent,pixelBlock:n}}getClippingGeometry(e){var t;let i=this._clippingGeometry.get("0");if(!e||!i)return i;let r=String((t=e).wkid??t.wkt??t.wkt2),n=this._clippingGeometry.get(r);return null!=n||(n=e.equals(i.spatialReference)?i:(0,h.uk)(i,e),this._clippingGeometry.set(r,n)),n}async _open(e){let{rasterFunction:t}=this;this.primaryRasters?.rasters?.length?t.sourceRasters=this.primaryRasters.rasters:(this.primaryRasters=t.getPrimaryRasters(),this.rasterJobHandler&&this.primaryRasters.rasters?.forEach(e=>e.rasterJobHandler=this.rasterJobHandler));let{rasters:i,rasterIds:r}=this.primaryRasters,s=i.map(t=>t.rasterInfo?void 0:t.open(e));await Promise.all(s);let l=i.map(({rasterInfo:e})=>e),a=t.bind({rasterInfos:l,rasterIds:r});if(t.rawSourceRasterInfos=l,!a.success||0===l.length)throw new n.A("raster-function:open",`cannot bind the function: ${a.error??""}`);let o="Table"===t.functionName?t:t.functionArguments?.raster;"Table"===o?.functionName&&(t.rasterInfo.attributeTable=d.A.fromJSON(o.functionArguments.attributeTableAsRecordSet)),await this.syncJobHandler();let u=l[0];this.hasUniqueSourceStorageInfo=1===l.length||l.slice(1).every(e=>(function(e,t){let{storageInfo:i,pixelSize:r,spatialReference:n,extent:s}=e,{storageInfo:l,pixelSize:a,spatialReference:o,extent:u}=t;return r.x===a.x&&r.y===a.y&&n.equals(o)&&s.equals(u)&&i.blockHeight===l.blockHeight&&i.blockWidth===l.blockWidth&&i.maximumPyramidLevel===l.maximumPyramidLevel})(e,u)),this.set("sourceJSON",i[0].sourceJSON),this.set("rasterInfo",t.rasterInfo),await this._updateClipGeometry()}async syncJobHandler(){return this.rasterJobHandler?.updateRasterFunction(this.rasterFunction)}async _updateClipGeometry(){let e=this.rasterFunction.getClippingGeometries()[0],t=e?.clippingGeometry;if(t&&"inside"===e.clippingType){let{extent:e}=this.rasterInfo,{difference:r,densify:n}=await Promise.all([i.e(472),i.e(8255)]).then(i.bind(i,40636)),s=n(a.A.fromExtent(e),2*(e.width+e.height)/40);t=r(s=(0,h.uk)(s,t.spatialReference),t)}this._clippingGeometry.clear(),t&&this._clippingGeometry.set("0",t)}};(0,r._)([(0,s.MZ)({type:String,json:{write:!0}})],m.prototype,"datasetFormat",void 0),(0,r._)([(0,s.MZ)()],m.prototype,"tileType",void 0),(0,r._)([(0,s.MZ)()],m.prototype,"rasterFunction",void 0),(0,r._)([(0,s.MZ)()],m.prototype,"primaryRasters",void 0);let f=m=(0,r._)([(0,l.$)("esri.layers.support.rasterDatasets.FunctionRaster")],m)},78218:(e,t,i)=>{i.d(t,{o:()=>H});var r=i(81856),n=i(39166),s=i(32391),l=i(61939),a=i(91838),o=i(86942);i(57845),i(33638);var u=i(33498),c=i(53480),h=i(12709),d=i(39960),m=i(91463),f=i(71760),p=i(21371),y=i(76572),g=i(22580),x=i(99132),_=i(48305),b=i(76809),R=i(84324),I=i(33768),w=i(72076),v=i(24088),S=i(18402),k=i(18801),M=i(34455),T=i(51725),F=i(2609),P=i(82330),C=i(31025),J=i(82698),A=i(88389),B=i(37810);let H=e=>{let t=class extends e{constructor(...e){super(...e),this._isConstructedFromFunctionRaster=!1,this._rasterJobHandler={instance:null,refCount:0,connectionPromise:null},this.bandIds=null,this.copyright=null,this.interpolation=null,this.multidimensionalSubset=null,this.raster=null,this.serviceRasterInfo=null,this.sourceJSON=null,this.spatialReference=null,this.symbolizer=null,this._isConstructedFromFunctionRaster="Function"===e[0]?.raster?.datasetFormat}get fullExtent(){return this.serviceRasterInfo?.extent}set multidimensionalDefinition(e){this._set("multidimensionalDefinition",e),this.updateRenderer()}set rasterFunction(e){"none"===e?.functionName?.toLowerCase()&&(e=void 0),this._set("rasterFunction",e),this.updateRasterFunction()}set url(e){this._set("url",(0,p.Jf)(e,l.A.getLogger(this)))}get renderer(){if("imagery-tile"!==this.type)return this.internalRenderer;let{activePresetRendererName:e,presetRenderers:t}=this;if(e){let i=t?.find(({name:t})=>t===e);return i?.renderer.clone()}return this.internalRenderer}set renderer(e){"imagery-tile"===this.type&&(this.activePresetRendererName=null),this.internalRenderer=e}set internalRenderer(e){null==e&&null==this.rasterFunction?this._configDefaultRenderer("override"):(this._set("internalRenderer",e),this.updateRenderer())}readRenderer(e,t,i){let r=t?.layerDefinition?.drawingInfo?.renderer;return(0,J.LF)(r,i)||void 0}async convertVectorFieldData(e,t){let{serviceRasterInfo:i}=this;if(null==e||!i)return null;let r=this._rasterJobHandler.instance,n=i.dataType;return r?r.convertVectorFieldData({pixelBlock:e,dataType:n},t):(0,F.FI)(e,n)}async computeStatisticsHistograms(e,t){await this.load(t),e=(0,o.PZ)(A.A,e).clone();let{serviceRasterInfo:i}=this;if(null==i)throw new s.A("imagery-tile-mixin:compute-statistics-histograms","serviceRasterInfo must be specified");let{geometry:r}=e;if(null==r)throw new s.A("imagery-tile-mixin:compute-statistics-histograms","geometry must be specified");let n=r,{spatialReference:l}=i;r.spatialReference.equals(l)||(await (0,M.Hh)(),n="extent"===r.type?(0,M._l)(r,l):(0,M.uk)(r,l));let a=e.pixelSize??new d.A({x:i.pixelSize.x,y:i.pixelSize.y,spatialReference:l}),{extent:u,width:c,height:h}=(0,S.b7)(i,n,a),m=await this.fetchPixels(u,c,h,{...t,interpolation:"nearest"});if(null==m.pixelBlock)throw new s.A("imagery-tile-mixin:compute-statistics-histograms","failed to fetch pixels");let f=await (0,S.$Q)(m.pixelBlock,u,n),p=this._rasterJobHandler.instance;return p?p.computeStatisticsHistograms({pixelBlock:f},t):(0,T.eH)(f)}async createFlowMesh(e,t){let i=this._rasterJobHandler.instance;return i?i.createFlowMesh(e,t):(0,B.CW)(e.meshType,e.simulationSettings,e.flowData,null!=t.signal?t.signal:(new AbortController).signal)}normalizeRasterFetchOptions(e){let{multidimensionalInfo:t}=this.serviceRasterInfo??{};if(null==t)return e;let i=(0,v.XU)({rasterInfo:this.raster.rasterInfo,multidimensionalDefinition:e.multidimensionalDefinition||this.multidimensionalDefinition,timeExtent:e.timeExtent??this.timeExtent,multidimensionalSubset:this.multidimensionalSubset});return{...e,multidimensionalDefinition:i}}async updateRasterFunction(){return this.loaded&&"imagery-tile"===this.type&&(this.rasterFunction||this._cachedRasterFunctionJson)&&JSON.stringify(this.rasterFunction)!==JSON.stringify(this._cachedRasterFunctionJson)&&(this._cachedRasterFunctionJson=this.rasterFunction?.toJSON(),this._rasterFunctionUpdatePromise=this._updateRasterFunction()),this._rasterFunctionUpdatePromise}async updateRenderer(){let{loaded:e,symbolizer:t}=this;if(!e||!t||!this.renderer)return;let{rasterInfo:i}=this.raster,r=(0,v.ct)(i,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),n=r?.name,s=(0,P.$P)({...this.renderer.toJSON(),variableName:n});if(JSON.stringify(this._cachedRendererJson)===JSON.stringify(s))return;let l=this._rasterJobHandler.instance;l&&(t.rasterInfo=(0,P.m7)(i,n),t.rendererJSON=s,t.bind(),await l.updateSymbolizer(t),this._cachedRendererJson=s)}async applyRenderer(e,t){let i=e?.pixelBlock;if(!(null!=i&&i.pixels&&i.pixels.length>0))return null;await this.updateRenderer();let r=this._rasterJobHandler.instance,n=this.bandIds??[];return r?await r.symbolize({...e,simpleStretchParams:t,bandIds:n}):this.symbolizer.symbolize({...e,simpleStretchParams:t,bandIds:n})}getTileUrl(e,t,i){return"RasterTileServer"===this.raster.datasetFormat?`${this.url}/tile/${e}/${t}/${i}`:""}getCompatibleTileInfo(e,t,i=!1){if(!this.loaded||null==t)return null;if(i&&e.equals(this.spatialReference))return this.tileInfo;let r=(0,f.Vp)(e);return I.A.create({size:256,spatialReference:e,origin:r?{x:r.origin[0],y:r.origin[1]}:{x:t.xmin,y:t.ymax}})}getCompatibleFullExtent(e){return this.loaded?(this._compatibleFullExtent?.spatialReference.equals(e)||(this._compatibleFullExtent=this.raster.computeExtent(e)),this._compatibleFullExtent):null}async fetchTile(e,t,r,s={}){if(i(this),s.requestAsImageElement){let i=this.getTileUrl(e,t,r);return(0,n.A)(i,{responseType:"image",query:{...this.refreshParameters,...this.raster.ioConfig.customFetchParameters},signal:s.signal}).then(e=>e.data)}let{serviceRasterInfo:l}=this;if(null!=l.multidimensionalInfo&&null==(s=this.normalizeRasterFetchOptions(s)).multidimensionalDefinition){let i=s.tileInfo||l.storageInfo.tileInfo;return{extent:this.raster.getTileExtentFromTileInfo(e,t,r,i),pixelBlock:null}}return await this._initJobHandler(),await this.updateRasterFunction(),"raster-shaded-relief"===this.renderer?.type&&(s={...s,buffer:{cols:1,rows:1}}),this.raster.fetchTile(e,t,r,s)}async fetchPixels(e,t,i,r={}){return null!=this.serviceRasterInfo.multidimensionalInfo&&null==(r=this.normalizeRasterFetchOptions(r)).multidimensionalDefinition?{extent:e,pixelBlock:null}:(await this._initJobHandler(),await this.updateRasterFunction(),t=Math.round(t),i=Math.round(i),this.raster.fetchPixels(e,t,i,r))}async identify(e,t={}){await this.load();let{raster:i,serviceRasterInfo:r}=this;if(null!=r?.multidimensionalInfo&&!(r.hasMultidimensionalTranspose&&((0,v.DY)(t.multidimensionalDefinition)||t.transposedVariableName||t.timeExtent))&&null==(t=this.normalizeRasterFetchOptions(t)).multidimensionalDefinition)return{location:e,value:null};let n=this.multidimensionalSubset?.areaOfInterest;if(n&&!n.contains(e))throw new s.A("imagery-tile-mixin:identify","the request cannot be fulfilled when falling outside of the multidimensional subset");return i.identify(e,t)}increaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount++}decreaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount--,this._rasterJobHandler.refCount<=0&&this._shutdownJobHandler()}hasStandardTime(){let e=this.serviceRasterInfo?.multidimensionalInfo;if(null==e||"standard-time"!==this.serviceRasterInfo?.dataType)return!1;let t=this.multidimensionalDefinition,i=t?.[0]?.variableName;return e.variables.some(e=>e.name===i&&(!t?.[0].dimensionName||e.dimensions.some(e=>"StdTime"===e.name)))}getStandardTimeValue(e){return new Date((0,v.$E)(e)).toISOString()}getMultidimensionalSubsetVariables(e){let t=e??this.serviceRasterInfo?.multidimensionalInfo;return(0,v.z2)(this.multidimensionalSubset,t)}_configDefaultSettings(){this._configDefaultInterpolation(),this.multidimensionalDefinition||(this.multidimensionalDefinition=(0,v.fy)(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset})),this.rasterFunction&&"Function"===this.raster.datasetFormat&&(this._cachedRasterFunctionJson=this.rasterFunction.toJSON()),this._configDefaultRenderer()}_initJobHandler(){if(null!=this._rasterJobHandler.connectionPromise)return this._rasterJobHandler.connectionPromise;let e=new R.A;return this._rasterJobHandler.connectionPromise=e.initialize().then(async()=>{i(this),this._rasterJobHandler.instance=e,this.raster.rasterJobHandler=e,"Function"===this.raster.datasetFormat&&this.raster.syncJobHandler(),this.rasterFunction&&await this.updateRasterFunction().catch(()=>{}),this.renderer&&this.updateRenderer()}).catch(()=>{}),this._rasterJobHandler.connectionPromise}_shutdownJobHandler(){this._rasterJobHandler.instance&&this._rasterJobHandler.instance.destroy(),this._rasterJobHandler.instance=null,this._rasterJobHandler.connectionPromise=null,this._rasterJobHandler.refCount=0,this._cachedRendererJson=null,this.raster&&(this.raster.rasterJobHandler=null)}_configDefaultInterpolation(){if(null==this.interpolation){i(this);let{raster:e}=this,t=(0,P.w6)(e.rasterInfo,e.tileType,this.sourceJSON?.defaultResamplingMethod);this._set("interpolation",t)}}_configDefaultRenderer(e="no"){i(this);let{rasterInfo:t}=this.raster,r=(0,v.ct)(t,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),n=r?.name,s=(0,P.I8)({variableName:n,rasterFunctionName:this.rasterFunction?.functionName,presetRenderers:this.presetRenderers});if(!this.bandIds&&t.bandCount>1&&(this.bandIds=s?.bandIds??(0,P.ci)(t)),!this.renderer||"override"===e){let e=(0,P.Mm)(this.raster),i=s?.renderer??(0,P.PD)(t,{bandIds:this.bandIds,variableName:n,rasterFunctionColorRamp:e}),r=t.statistics,l=r&&r.length>0?r[0]:null,a=l?.max??0,o=l?.min??0;"WCSServer"===this.raster.datasetFormat&&"raster-stretch"===i.type&&(a>1e24||o<-1e24)&&(i.dynamicRangeAdjustment=!0,i.customStatistics=null,"none"===i.stretchType&&(i.stretchType="min-max")),this.renderer=i}let a=(0,P.$P)({...this.renderer.toJSON(),variableName:n}),o=(0,P.m7)(t,n);this.symbolizer?(this.symbolizer.rendererJSON=a,this.symbolizer.rasterInfo=o):this.symbolizer=new C.A({rendererJSON:a,rasterInfo:o});let u=this.symbolizer.bind();if(u.success){if("auto"===e){let{colormap:e}=this.raster.rasterInfo,t=this.renderer;if(null!=e&&"raster-colormap"===t.type)JSON.stringify((0,P.PD)(this.raster.rasterInfo))!==JSON.stringify(t)&&this._configDefaultRenderer("override");else if("raster-stretch"===t.type){let e=this.bandIds?.length,i=t.customStatistics?.length;!t.dynamicRangeAdjustment&&i&&e&&i!==e&&this._configDefaultRenderer("override")}}}else l.A.getLogger(this).warn("imagery-tile-mixin",u.error||"The given renderer is not supported by the layer."),"auto"===e&&this._configDefaultRenderer("override")}async _updateRasterFunction(){if(this._isConstructedFromFunctionRaster&&"Function"===this.raster.datasetFormat){let e=this.raster.rasterFunction.toJSON();return void(!this.rasterFunction&&e&&this._set("rasterFunction",b.A.fromJSON(e)))}let e,t=this.raster,i=!1;"Function"===t.datasetFormat?(t=(e=t.primaryRasters.rasters)[0],i=!0):e=[t];let{rasterFunction:r}=this;if(r){let i={raster:t};e.length>1&&e.forEach(e=>i[e.url]=e);let n=(0,k.vt)(r.functionDefinition?.toJSON()??r.toJSON(),i),s=new w.A({rasterFunction:n});s.rasterJobHandler=this._rasterJobHandler.instance,await s.open(),this.raster=s}else this.raster=t,await t.open();if(this._cachedRendererJson=null,!i&&!r)return;let{bandIds:n}=this,{bandCount:s}=this.raster.rasterInfo,l=n?.length?n.some(e=>e>=s):s>=3;n&&(l||this.renderer&&"raster-stretch"!==this.renderer.type)&&this._set("bandIds",null),this._configDefaultRenderer("auto")}};function i(e){if(!e.raster||!e.serviceRasterInfo)throw new s.A("imagery-tile","no raster")}return(0,r._)([(0,a.MZ)({clonable:!1})],t.prototype,"_cachedRendererJson",void 0),(0,r._)([(0,a.MZ)({clonable:!1})],t.prototype,"_cachedRasterFunctionJson",void 0),(0,r._)([(0,a.MZ)({clonable:!1})],t.prototype,"_compatibleFullExtent",void 0),(0,r._)([(0,a.MZ)({clonable:!1})],t.prototype,"_isConstructedFromFunctionRaster",void 0),(0,r._)([(0,a.MZ)({clonable:!1})],t.prototype,"_rasterJobHandler",void 0),(0,r._)([(0,a.MZ)({clonable:!1})],t.prototype,"_rasterFunctionUpdatePromise",void 0),(0,r._)([(0,a.MZ)({type:[o.jz],json:{write:{overridePolicy(){return{enabled:!this.loaded||"Raster"===this.raster.tileType||"0,1,2"!==this.bandIds?.join(",")}}}}})],t.prototype,"bandIds",void 0),(0,r._)([(0,a.MZ)({json:{origins:{service:{read:{source:"copyrightText"}}}}})],t.prototype,"copyright",void 0),(0,r._)([(0,a.MZ)({json:{read:!1}})],t.prototype,"fullExtent",null),(0,r._)([(0,a.MZ)({json:{write:{overridePolicy(){return{enabled:!this.loaded||"Raster"===this.raster.tileType||"bilinear"!==this.interpolation}}}}}),(0,u.e)(_.SZ)],t.prototype,"interpolation",void 0),(0,r._)([(0,a.MZ)()],t.prototype,"ioConfig",void 0),(0,r._)([(0,a.MZ)({type:[g.A],json:{write:!0}})],t.prototype,"multidimensionalDefinition",null),(0,r._)([(0,a.MZ)({type:x.A,json:{write:!0}})],t.prototype,"multidimensionalSubset",void 0),(0,r._)([(0,a.MZ)()],t.prototype,"raster",void 0),(0,r._)([(0,a.MZ)({type:b.A})],t.prototype,"rasterFunction",null),(0,r._)([(0,a.MZ)()],t.prototype,"serviceRasterInfo",void 0),(0,r._)([(0,a.MZ)()],t.prototype,"sourceJSON",void 0),(0,r._)([(0,a.MZ)({readOnly:!0,type:m.A,json:{read:!1}})],t.prototype,"spatialReference",void 0),(0,r._)([(0,a.MZ)({type:I.A})],t.prototype,"tileInfo",void 0),(0,r._)([(0,a.MZ)(y.OZ)],t.prototype,"url",null),(0,r._)([(0,a.MZ)()],t.prototype,"renderer",null),(0,r._)([(0,a.MZ)({types:J.uy,json:{name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy(){let e="raster-stretch"===this.renderer?.type&&"none"===this.renderer.stretchType&&!this.renderer.useGamma;return{enabled:!this.loaded||"Raster"===this.raster.tileType||!e}}},origins:{"web-scene":{types:J.Gj,name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy:e=>({enabled:e&&"vector-field"!==e.type&&"flow"!==e.type})}}}}})],t.prototype,"internalRenderer",null),(0,r._)([(0,c.w)("internalRenderer")],t.prototype,"readRenderer",null),(0,r._)([(0,a.MZ)({clonable:!1})],t.prototype,"symbolizer",void 0),t=(0,r._)([(0,h.$)("esri.layers.mixins.ImageryTileMixin")],t)}},82245:(e,t,i)=>{i.d(t,{A:()=>C});var r=i(81856),n=i(39166),s=i(32391),l=i(92713),a=i(61939),o=i(92753),u=i(61590),c=i(91838),h=i(86942);i(57845),i(33638);var d=i(12709),m=i(61414),f=i(39960),p=i(91463),y=i(21371),g=i(76572),x=i(22580),_=i(49667),b=i(8946),R=i(33768),I=i(24088),w=i(47549),v=i(50518),S=i(10303),k=i(93782),M=i(34455),T=i(2609);let F=0,P=class extends l.A{constructor(){super(...arguments),this._tileFetchQueue=new u.QueueProcessor({concurrency:32,process:(e,t)=>this._fetchRawTile(e.pyramidLevel,e.row,e.col,{...e.options,signal:t})}),this.datasetName=null,this.datasetFormat=null,this.hasUniqueSourceStorageInfo=!0,this.rasterInfo=null,this.ioConfig={sampling:"closest"}}normalizeCtorArgs(e){return e?.ioConfig&&(e={...e,ioConfig:{resolution:null,bandIds:null,sampling:"closest",tileInfo:R.A.create(),...e.ioConfig}}),e}get _isGlobalWrappableSource(){let{rasterInfo:e}=this,t=(0,M.FT)(e.spatialReference);return null!=t&&e.extent.width>=t/2}get _hasNoneOrGCSShiftTransform(){let{transform:e}=this.rasterInfo;return null==e||"gcs-shift"===e.type}set rasterJobHandler(e){this._set("rasterJobHandler",e),"Function"===this.datasetFormat&&this.primaryRasters?.rasters?.forEach(t=>t.rasterJobHandler=e)}get rasterId(){return this.url||"rasterId-"+F++}set url(e){this._set("url",(0,y.Jf)(e,a.A.getLogger(this)))}async open(e){return this._openPromise??=(0,M.Hh)().then(()=>this._open(e)),this._openPromise}async fetchTile(e,t,i,r={}){let n=r.tileInfo||this.rasterInfo.storageInfo.tileInfo,s=this.getTileExtentFromTileInfo(e,t,i,n);return r={noClip:!0,...r},this.fetchPixels(s,n.size[0],n.size[1],r)}async identify(e,t={}){e=(0,h.PZ)(f.A,e).clone().normalize();let{multidimensionalDefinition:i,timeExtent:r}=t,{rasterInfo:n}=this,{hasMultidimensionalTranspose:s,multidimensionalInfo:l}=n,{transposedVariableName:a}=t,o=null!=l&&s&&(null!=r||(0,I.DY)(i));o&&!a&&(a=null!=i&&i.length>0?i[0].variableName??void 0:l.variables[0].name,t={...t,transposedVariableName:a});let{spatialReference:u,extent:c}=n,{datumTransformation:d}=t=this._getRequestOptionsWithSliceId(t),p=(0,M._I)(e,u,d);if(!c.intersects(p))return{location:p,value:null};if(null!=n.transform){let e=n.transform.inverseTransform(p);if(!n.nativeExtent.intersects(e))return{location:e,value:null};p=e}let y=0,g=null!=a&&null!=l&&n.hasMultidimensionalTranspose;if("Function"===this.datasetFormat){let e,r=this.primaryRasters.rasters[0];if(g)return r.identify(p,t);let{pixelSize:s}=n,l=3*s.x/2,a=3*s.y/2,o=new m.A({xmin:p.x-l,xmax:p.x+l,ymin:p.y-a,ymax:p.y+a,spatialReference:u}),c={interpolation:"nearest",multidimensionalDefinition:i,sliceId:t.sliceId},{pixelBlock:h}=await r.fetchPixels(o,3,3,c),{pixelBlock:d}=await this.fetchPixels(o,3,3,c);if(null==h)return{location:p,value:null};let f=Math.floor(4.5),y=!h.mask||h.mask[f]?h.pixels.map(e=>e[f]):null;return null!=d&&(e=!d.mask||d.mask[f]?d.pixels.map(e=>e[f]):void 0),{location:p,value:y,processedValue:e,pyramidLevel:0}}if(!g){if(t.srcResolution)y=(0,M.t$)(t.srcResolution,n,this.ioConfig.sampling).pyramidLevel;else if(null==(y=await this.computeBestPyramidLevelForLocation(e,t)))return{location:p,value:null}}let x=this.identifyPixelLocation(p,y,null,g);if(null===x)return{location:p,value:null};let{row:_,col:b,rowOffset:R,colOffset:v,blockWidth:S}=x,k=a??t.sliceId,T=(0,w.ph)(this.rasterId,k),F=`${y}/${_}/${b}`,P=(0,w.gd)(T,null,F);null==P&&(P=this.fetchRawTile(y,_,b,t),(0,w.no)(T,null,F,P));let C=await P;return C?.pixels?.length?this._processIdentifyResult(C,{srcLocation:p,position:R*S+v,pyramidLevel:y,useTransposedTile:!!g,requestSomeSlices:o,identifyOptions:t}):{location:p,value:null}}async fetchPixels(e,t,i,r={}){e=(0,M.Ps)(e);let{_hasNoneOrGCSShiftTransform:n}=this;if((r=this._getRequestOptionsWithSliceId(r)).requestRawData&&n)return this._fetchPixels(e,t,i,r);let s=(0,M.FT)(e.spatialReference),l=(0,M.OM)(e);if(null==s||0===l||1===l&&this._isGlobalWrappableSource&&n)return this._fetchPixels(e,t,i,r);if(l>=3)return{extent:e,pixelBlock:null};let a=[],{xmin:o,xmax:u}=e,c=Math.round(s/(u-o)*t),h=c-Math.round((s/2-o)/(u-o)*t),d=0,f=[];for(let n=0;n<=l;n++){let p=new m.A({xmin:0===n?o:-s/2,xmax:n===l?u-s*n:s/2,ymin:e.ymin,ymax:e.ymax,spatialReference:e.spatialReference}),y=0===n?c-h:n===l?t-d:c;d+=y,f.push(y);let g=r.disableWrapAround&&n>0?null:this._fetchPixels(p,y,i,r);a.push(g)}let p=(await Promise.all(a)).map(e=>e?.pixelBlock),y=null,g={width:t,height:i};return y=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:p,srcMosaicSize:g,destDimension:null,coefs:null,sampleSpacing:null,interpolation:"nearest",alignmentInfo:null,blockWidths:f},r)).pixelBlock:(0,k.z7)(p,g,{blockWidths:f}),{extent:e,srcExtent:(0,M._l)(e,this.rasterInfo.spatialReference,r.datumTransformation),pixelBlock:y}}async fetchRawPixels(e,t,i,r={}){let n;t={x:Math.floor(t.x),y:Math.floor(t.y)};let s=await this._fetchRawTiles(e,t,i,r),{nativeExtent:l,nativePixelSize:a,storageInfo:o}=this.rasterInfo,u=2**e,c=a.x*u,h=a.y*u,d=new m.A({xmin:l.xmin+c*t.x,xmax:l.xmin+c*(t.x+i.width-1),ymin:l.ymax-h*(t.y+i.height-1),ymax:l.ymax-h*t.y,spatialReference:l.spatialReference});if(!s)return{extent:d,srcExtent:d,pixelBlock:null};let{pixelBlocks:f,mosaicSize:p}=s;if(1===f.length&&null!=f[0]&&f[0].width===i.width&&f[0].height===i.height)return{extent:d,srcExtent:d,pixelBlock:s.pixelBlocks[0]};let y=e>0?o.pyramidBlockWidth:o.blockWidth,g=e>0?o.pyramidBlockHeight:o.blockHeight,x={x:t.x%y,y:t.y%g};return{extent:d,srcExtent:d,pixelBlock:this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:f,srcMosaicSize:p,destDimension:i,clipOffset:x,clipSize:i,coefs:null,sampleSpacing:null,interpolation:r.interpolation,alignmentInfo:null,blockWidths:null},r)).pixelBlock:(0,k.z7)(f,p,{clipOffset:x,clipSize:i})}}fetchRawTile(e,t,i,r){throw new s.A("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")}computeExtent(e){return(0,M._l)(this.rasterInfo.extent,e)}decodePixelBlock(e,t){return!this.rasterJobHandler||t.useCanvas?(0,S.D)(e,t):this.rasterJobHandler.decode({data:e,options:t})}async request(e,t,i=0){let{customFetchParameters:r}=this.ioConfig,{range:s,query:l,headers:a}=t;i=i??t.retryCount??this.ioConfig.retryCount;let o=s?{Range:`bytes=${s.from}-${s.to}`}:null;try{return await (0,n.A)(e,{...t,query:{...l,...r},headers:{...a,...o}})}catch(r){if(i>0)return i--,this.request(e,t,i);throw r}}getSliceIndex(e){let{multidimensionalInfo:t}=this.rasterInfo;return null==t||null==e||0===e.length?null:(0,I.NG)(e,t)}getTileExtentFromTileInfo(e,t,i,r){let n=r.lodAt(e);return this.getTileExtent({x:n.resolution,y:n.resolution},t,i,r.origin,r.spatialReference,r.size)}updateTileInfo(){let{storageInfo:e,spatialReference:t,extent:i,pixelSize:r}=this.rasterInfo,{pyramidResolutions:n}=e;if(!e.tileInfo){let s=[],l=e.maximumPyramidLevel||0,a=(r.x+r.y)/2,o=1/.0254*96*a;for(let e=0;e<=l&&(s.unshift(new _.A({level:l-e,resolution:a,scale:o})),e!==l);e++)if(n){let t=(n[e].x+n[e].y)/2;o*=t/a,a=t}else a*=2,o*=2;let u=new f.A({x:i.xmin,y:i.ymax,spatialReference:t});e.tileInfo=new R.A({origin:u,size:[e.blockWidth,e.blockHeight],spatialReference:t,lods:s}),e.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(e,t=512,i=512,r){let{width:n,height:s,nativeExtent:l,pixelSize:a,spatialReference:o}=e,u=new f.A({x:l.xmin,y:l.ymax,spatialReference:o});null==r&&(r=Math.max(0,Math.round(Math.log(Math.max(n,s))/Math.LN2-8)));let c=this.computeBlockBoundary(l,512,512,{x:l.xmin,y:l.ymax},[a],r);e.storageInfo=new b.A({blockWidth:t,blockHeight:i,pyramidBlockWidth:t,pyramidBlockHeight:i,origin:u,firstPyramidLevel:1,maximumPyramidLevel:r,blockBoundary:c})}async computeBestPyramidLevelForLocation(e,t={}){return 0}computeBlockBoundary(e,t,i,r,n,s=0,l=2){if(1===n.length&&s>0){let{x:e,y:t}=(n=[...n])[0];for(let i=0;i<s;i++)e*=l,t*=l,n.push({x:e,y:t})}let a=[],{x:o,y:u}=r;for(let r=0;r<n.length;r++){let{x:s,y:l}=n[r];a.push({minCol:Math.floor((e.xmin-o+.1*s)/t/s),maxCol:Math.floor((e.xmax-o-.1*s)/t/s),minRow:Math.floor((u-e.ymax+.1*l)/i/l),maxRow:Math.floor((u-e.ymin-.1*l)/i/l)})}return a}getPyramidPixelSize(e){let{nativePixelSize:t}=this.rasterInfo,{pyramidResolutions:i,pyramidScalingFactor:r}=this.rasterInfo.storageInfo;if(0===e)return t;if(null!=i&&i.length)return i[e-1];let n=r**e;return{x:t.x*n,y:t.y*n}}identifyPixelLocation(e,t,i,r){let{spatialReference:n,nativeExtent:s,storageInfo:l}=this.rasterInfo,{maximumPyramidLevel:a,origin:o,transposeInfo:u}=l,c=r&&null!=u?u.tileSize[0]:l.blockWidth,h=r&&null!=u?u.tileSize[1]:l.blockHeight,d=(0,M._I)(e,n,i);if(!s.intersects(d)||t<0||t>a)return null;let{x:m,y:f}=this.getPyramidPixelSize(t),p=(o.y-d.y)/f/h,y=(d.x-o.x)/m/c,g=Math.min(h-1,Math.floor((p-Math.floor(p))*h)),x=Math.min(c-1,Math.floor((y-Math.floor(y))*c));return{pyramidLevel:t,row:Math.floor(p),col:Math.floor(y),rowOffset:g,colOffset:x,blockWidth:c,srcLocation:d}}getTileExtent(e,t,i,r,n,s){let[l,a]=s,o=r.x+i*l*e.x,u=o+l*e.x,c=r.y-t*a*e.y,h=c-a*e.y;return new m.A({xmin:o,xmax:u,ymin:h,ymax:c,spatialReference:n})}getBlockWidthHeight(e){return{blockWidth:e>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:e>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}}isBlockOutside(e,t,i){let r=this.rasterInfo.storageInfo.blockBoundary[e];return!r||r.maxRow<t||r.maxCol<i||r.minRow>t||r.minCol>i}updateImageSpaceRasterInfo(e){let{pixelSize:t}=e,{width:i,height:r}=e,n=p.A.WebMercator;e.spatialReference=n,e.extent=e.nativeExtent=new m.A({xmin:-.5,ymax:.5,xmax:i-.5,ymin:.5-r,spatialReference:n}),e.isPseudoSpatialReference=!0,e.transform=null,e.pixelSize=new f.A({x:1,y:1,spatialReference:n});let{extent:s,storageInfo:l}=e;if(l){l.origin=new f.A({x:s.xmin,y:s.ymax,spatialReference:n});let{pyramidResolutions:i,tileInfo:r}=l;if(i&&i.forEach(e=>{e.x/=t.x,e.y/=t.y}),r){r.origin=l.origin;let t=(e.nativePixelSize.x+e.nativePixelSize.y)/2;r.lods.forEach((e,i)=>{e.resolution=t*2**i,e.scale=96*e.resolution/.0254})}}}async _fetchPixels(e,t,i,r={}){var n,s,l;let a,o=(0,M.OM)(e);if(o>=2)return{extent:e,pixelBlock:null};let u=this._getSourceDataInfo(e,t,i,r),{pyramidLevel:c,srcResolution:h,srcExtent:d,srcWidth:m,srcHeight:p,ul:y}=u;if(0===m||0===p)return{extent:e,srcExtent:d,pixelBlock:null};let{rasterInfo:g}=this,x=g.transform,_="gcs-shift"===x?.type,b=null!=(0,M.FT)(e.spatialReference);!_&&b||(o=(0,M.OM)(u.srcExtent,_));let R=await this._fetchRawTiles(c,y,{width:m,height:p,wrapCount:o},r);if(!R)return{extent:e,srcExtent:d,pixelBlock:null};let I=g.storageInfo,w=c>0?I.pyramidBlockWidth:I.blockWidth,v=c>0?I.pyramidBlockHeight:I.blockHeight,{x:S,y:F}=g.pixelSize;if(c>0){let{pyramidResolutions:e,pyramidScalingFactor:t}=I;if(null!=e&&e[c-1])({x:S,y:F}=e[c-1]);else{let e=t**c;S*=e,F*=e}}let P=g.spatialReference,C=new f.A({x:S,y:F,spatialReference:P}),J=w===m&&v===p&&y.x%w==0&&y.y%v==0,A=new f.A({x:(e.xmax-e.xmin)/t,y:(e.ymax-e.ymin)/i,spatialReference:e.spatialReference}),B=!e.spatialReference.equals(P),H=P.isGeographic?1e-9:1e-4,{datumTransformation:z}=r;if(!B&&J&&1===R.pixelBlocks.length&&w===t&&v===i&&(n=h,s=A,l=H,Math.abs(n.x-s.x)<l&&Math.abs(n.y-s.y)<l))return{extent:e,srcExtent:d,srcTilePixelSize:C,pixelBlock:R.pixelBlocks[0]};let D=b&&null!=(0,M.FT)(d.spatialReference)&&this._hasNoneOrGCSShiftTransform,N=r.requestProjectedLocalDirections&&this.rasterInfo.dataType.startsWith("vector");N&&!this.rasterJobHandler&&await (0,M.Hh)();let O=this.rasterJobHandler?await this.rasterJobHandler.getProjectionOffsetGrid({projectedExtent:e,srcBufferExtent:R.extent,pixelSize:A.toJSON(),datumTransformation:z,rasterTransform:x,hasWrapAround:o>0||D,isAdaptive:!1!==this.ioConfig.optimizeProjectionAccuracy,includeGCSGrid:N},r):(0,M.l0)({projectedExtent:e,srcBufferExtent:R.extent,pixelSize:A,datumTransformation:z,rasterTransform:x,hasWrapAround:o>0||D,isAdaptive:!1,includeGCSGrid:N}),E=!r.requestRawData,W={rows:O.spacing[0],cols:O.spacing[1]},q=this._hasNoneOrGCSShiftTransform?this._getRasterTileAlignmentInfo(c,R.extent.xmin):void 0,{pixelBlocks:Z,mosaicSize:L,isPartiallyFilled:G}=R,$=null;if(this.rasterJobHandler){let e=await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:Z,srcMosaicSize:L,destDimension:E?{width:t,height:i}:null,coefs:E?O.coefficients:null,sampleSpacing:E?W:null,projectDirections:N,gcsGrid:N?O.gcsGrid:null,isUV:"vector-uv"===this.rasterInfo.dataType,interpolation:r.interpolation,alignmentInfo:q,blockWidths:null},r);({pixelBlock:a,localNorthDirections:$}=e)}else{let e=(0,k.z7)(Z,L,{alignmentInfo:q});a=E?(0,k.$i)(e,{width:t,height:i},O.coefficients,W,r.interpolation):e,N&&O.gcsGrid&&($=(0,k.QF)({width:t,height:i},O.gcsGrid),a=(0,T.Y2)(a,this.rasterInfo.dataType,$))}return r.requestRawData||N?{extent:e,srcExtent:d,srcTilePixelSize:C,pixelBlock:a,transformGrid:O,localNorthDirections:$,isPartiallyFilled:G}:{extent:e,srcExtent:d,srcTilePixelSize:C,pixelBlock:a}}async _fetchRawTiles(e,t,i,r){let{origin:n,blockBoundary:s}=this.rasterInfo.storageInfo,{blockWidth:l,blockHeight:a}=this.getBlockWidthHeight(e),{x:o,y:u}=t,{width:c,height:h,wrapCount:d}=i,f=this._getRasterTileAlignmentInfo(e,0);r.buffer&&(o-=r.buffer.cols,u-=r.buffer.rows,c+=2*r.buffer.cols,h+=2*r.buffer.rows);let p=0,y=0,g=0;d&&null!=f&&({worldColumnCountFromOrigin:y,originColumnOffset:g,rightPadding:p}=f,y*f.blockWidth-p>=o+c&&(p=0));let x=Math.floor(o/l),_=Math.floor(u/a),b=Math.floor((o+c+p-1)/l),R=Math.floor((u+h+p-1)/a),I=s[e];if(!I)return null;let{minRow:w,minCol:v,maxCol:S,maxRow:k}=I;if(0===d&&(R<w||b<v||_>k||x>S))return null;let M=[],T=!1,F=null==this.ioConfig.allowPartialFill?r.allowPartialFill:this.ioConfig.allowPartialFill;for(let t=_;t<=R;t++)for(let i=x;i<=b;i++){let n=i;if(!r.disableWrapAround&&d&&null!=f&&y<=i&&(n=i-y-g),t>=w&&n>=v&&k>=t&&S>=n){let i=this._tileFetchQueue.push({pyramidLevel:e,row:t,col:n,options:r},{signal:r.signal});F?M.push(new Promise(e=>{i.then(t=>e(t)).catch(()=>{T=!0,e(null)})})):M.push(i)}else M.push(Promise.resolve(null))}if(0===M.length)return null;let P=await Promise.all(M),{spatialReference:C}=this.rasterInfo,{x:J,y:A}=this.getPyramidPixelSize(e);return{extent:new m.A({xmin:n.x+x*l*J,xmax:n.x+(b+1)*l*J,ymin:n.y-(R+1)*a*A,ymax:n.y-_*a*A,spatialReference:C}),pixelBlocks:P,mosaicSize:{height:(R-_+1)*a,width:(b-x+1)*l},isPartiallyFilled:T}}_fetchRawTile(e,t,i,r){let n=this.rasterInfo.storageInfo.blockBoundary[e];if(!n)return Promise.resolve(null);let{minRow:s,minCol:l,maxCol:a,maxRow:u}=n;if(t<s||i<l||t>u||i>a)return Promise.resolve(null);let c=(0,w.ph)(this.rasterId,r.sliceId),h=`${e}/${t}/${i}`,d=(0,w.gd)(c,r.registryId,h);if(null==d){let n=new AbortController;d=this.fetchRawTile(e,t,i,{...r,signal:n.signal}),(0,w.no)(c,r.registryId,h,d,n),d.catch(()=>(0,w.zo)(c,r.registryId,h))}return r.signal&&(0,o.u7)(r,()=>{(0,w.jX)(c,r.registryId,h)}),d}_computeMagDirValues(e){let{bandCount:t,dataType:i}=this.rasterInfo;if((2!==t||"vector-magdir"!==i)&&"vector-uv"!==i||2!==e?.length||!e[0]?.length)return null;let r=e[0].length;if("vector-magdir"===i){let t=e[1].map(e=>(e+360)%360);return[e[0],t]}let[n,s]=e,l=[],a=[];for(let e=0;e<r;e++){let[t,i]=(0,T.Lu)([n[e],s[e]]);l.push(t),a.push(i)}return[l,a]}_getRasterTileAlignmentInfo(e,t){return null==this._rasterTileAlignmentInfo&&(this._rasterTileAlignmentInfo=(0,M.DO)(this.rasterInfo)),null==this._rasterTileAlignmentInfo.pyramidsInfo?null:{startX:t,halfWorldWidth:this._rasterTileAlignmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlignmentInfo.hasGCSSShiftTransform,...this._rasterTileAlignmentInfo.pyramidsInfo[e]}}_getSourceDataInfo(e,t,i,r={}){let n={datumTransformation:r.datumTransformation,pyramidLevel:0,pyramidResolution:null,srcExtent:null,srcHeight:0,srcResolution:null,srcWidth:0,ul:{x:0,y:0}};r.srcResolution&&(n.srcResolution=r.srcResolution,this._updateSourceDataInfo(e,n));let s=this.rasterInfo.storageInfo.maximumPyramidLevel||0,{srcWidth:l,srcHeight:a,pyramidLevel:o}=n,u=l/t,c=a/i,h=o<s&&u*c>=16,d=o===s&&this._requireTooManySrcTiles(l,a,t,i);if(h||d||0===l||0===a){let l=new f.A({x:(e.xmax-e.xmin)/t,y:(e.ymax-e.ymin)/i,spatialReference:e.spatialReference}),a=(0,M.Wo)(l,this.rasterInfo.spatialReference,e,n.datumTransformation),d=!a||r.srcResolution&&a.x+a.y<r.srcResolution.x+r.srcResolution.y;if(h&&r.srcResolution&&d){let e=Math.round(Math.log(Math.max(u,c))/Math.LN2)-1;if(s-o+3>=e){let t=2**e;a={x:r.srcResolution.x*t,y:r.srcResolution.y*t}}}a&&(n.srcResolution=a,this._updateSourceDataInfo(e,n))}return this._requireTooManySrcTiles(n.srcWidth,n.srcHeight,t,i)&&(n.srcWidth=0,n.srcHeight=0),n}_requireTooManySrcTiles(e,t,i,r){let{tileInfo:n}=this.rasterInfo.storageInfo;return Math.ceil(e/n.size[0])*Math.ceil(t/n.size[1])>=256*Math.max(1,(i+r)/1024)||e/i>8||t/r>8}_updateSourceDataInfo(e,t){t.srcWidth=0,t.srcHeight=0;let{rasterInfo:i}=this,r=i.spatialReference,{srcResolution:n,datumTransformation:s}=t,{pyramidLevel:l,pyramidResolution:a,excessiveReading:o}=(0,M.t$)(n,i,this.ioConfig.sampling);if(o)return;let u=t.srcExtent||(0,M._l)(e,r,s);if(null==u)return;let c=i.transform;c&&(u=c.inverseTransform(u)),t.srcExtent=u;let{x:h,y:d}=i.storageInfo.origin,m=Math.floor((u.xmin-h)/a.x+.1),f=Math.floor((d-u.ymax)/a.y+.1),p=Math.floor((u.xmax-h)/a.x-.1),y=Math.floor((d-u.ymin)/a.y-.1),g=u.width<.1*a.x?0:p-m+1,x=u.height<.1*a.y?0:y-f+1;t.pyramidLevel=l,t.pyramidResolution=a,t.srcWidth=g,t.srcHeight=x,t.ul={x:m,y:f}}_getRequestOptionsWithSliceId(e){return null!=this.rasterInfo.multidimensionalInfo&&null==e.sliceId&&(e={...e,sliceId:this.getSliceIndex(e.multidimensionalDefinition)}),e}_processIdentifyResult(e,t){let i,{srcLocation:r,position:n,pyramidLevel:s,useTransposedTile:l}=t,a=e.pixels[0].length/e.width/e.height;if(!(!e.mask||e.mask[n]))return{location:r,value:null};let{multidimensionalInfo:o}=this.rasterInfo;if(null==o||!l){let t=e.pixels.map(e=>e[n]),i={location:r,value:t,pyramidLevel:s},l=this._computeMagDirValues(t.map(e=>[e]));return l?.length&&(i.magdirValue=l.map(e=>e[0])),i}let u=e.pixels.map(e=>e.slice(n*a,n*a+a)),c=this._computeMagDirValues(u),{requestSomeSlices:h,identifyOptions:d}=t,m=(0,I.QW)(o,d.transposedVariableName);if(h){let e=(0,I.xx)(m,d.multidimensionalDefinition,d.timeExtent);u=u.map(t=>e.map(e=>t[e])),c=c?.map(t=>e.map(e=>t[e])),m=e.map(e=>m[e])}let f=e.noDataValues||this.rasterInfo.noDataValue,p={pixels:u,pixelType:e.pixelType};return null!=f&&((0,v.Sp)(p,f),i=p.mask),{location:r,value:null,dataSeries:m.map((e,t)=>{let r={value:0===i?.[t]?null:u.map(e=>e[t]),multidimensionalDefinition:e.multidimensionalDefinition.map(e=>new x.A({...e,isSlice:!0}))};return c?.length&&(r.magdirValue=[c[0][t],c[1][t]]),r}),pyramidLevel:s}}};(0,r._)([(0,c.MZ)()],P.prototype,"_rasterTileAlignmentInfo",void 0),(0,r._)([(0,c.MZ)()],P.prototype,"_tileFetchQueue",void 0),(0,r._)([(0,c.MZ)({readOnly:!0})],P.prototype,"_isGlobalWrappableSource",null),(0,r._)([(0,c.MZ)({readOnly:!0})],P.prototype,"_hasNoneOrGCSShiftTransform",null),(0,r._)([(0,c.MZ)()],P.prototype,"_openPromise",void 0),(0,r._)([(0,c.MZ)()],P.prototype,"rasterJobHandler",null),(0,r._)([(0,c.MZ)({readOnly:!0})],P.prototype,"rasterId",null),(0,r._)([(0,c.MZ)(g.OZ)],P.prototype,"url",null),(0,r._)([(0,c.MZ)({type:String,json:{write:!0}})],P.prototype,"datasetName",void 0),(0,r._)([(0,c.MZ)({type:String,json:{write:!0}})],P.prototype,"datasetFormat",void 0),(0,r._)([(0,c.MZ)()],P.prototype,"hasUniqueSourceStorageInfo",void 0),(0,r._)([(0,c.MZ)()],P.prototype,"rasterInfo",void 0),(0,r._)([(0,c.MZ)()],P.prototype,"ioConfig",void 0),(0,r._)([(0,c.MZ)()],P.prototype,"sourceJSON",void 0);let C=P=(0,r._)([(0,d.$)("esri.layers.support.rasterDatasets.BaseRaster")],P)}}]);