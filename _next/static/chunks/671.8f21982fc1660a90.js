"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[671,8288],{8288:(e,t,s)=>{s.d(t,{G:()=>i,S:()=>r});class i{*[Symbol.iterator](){let e=this.next();for(;e;)yield e,e=this.next()}}class r extends i{constructor(e){super(),this.m_iGeom=-1,this.m_aGeoms=e?e.slice():[]}next(){if(this.m_iGeom<this.m_aGeoms.length-1){let e=this.m_aGeoms[++this.m_iGeom];return this.m_aGeoms[this.m_iGeom]=null,e}return null}tock(){return!1}getGeometryID(){return this.m_iGeom}getRank(){return 1}}},10671:(e,t,s)=>{s.d(t,{g7:()=>M,yv:()=>G,fz:()=>E});var i,r=s(8288),n=s(16404),m=s(40224),h=s(73750),l=s(81856),a=s(31632),o=s(92656),u=s(32045),_=s(26251),c=s(64601),f=s(78702);class g{getOperatorType(){return 10104}accelerateGeometry(e,t,s){return!1}canAccelerateGeometry(e){return!1}supportsCurves(){return!0}isSimple(e,t,s,i,r){return 5===(0,m.aj)(e,t,s,i,r)}executeMany(e,t,s,i){return new d(e,t,s,i)}execute(e,t,s,i){let m=new r.S([e]),h=this.executeMany(m,t,s,i).next();return h||(0,n.c)("null output"),h}}class d extends r.G{constructor(e,t,s,i){super(),e||(0,n.t)(""),this.m_progressTracker=i,this.m_bForceSimplify=s,this.m_index=-1,this.m_inputGeometryCursor=e,this.m_spatialReference=t}next(){let e=this.m_inputGeometryCursor.next();return e?((0,n.d)(e),this.m_index=this.m_inputGeometryCursor.getGeometryID(),this.simplify(e)):null}getGeometryID(){return this.m_index}tock(){return!1}getRank(){return 1}simplify(e){return e||(0,n.t)(""),(0,m.ak)(e,this.m_spatialReference,this.m_bForceSimplify,this.m_progressTracker)}}function p(e,t,s,i,r,n){return{m_from:e.clone(),m_to:t.clone(),m_center:s.clone(),m_next:r,m_type:i}}function P(e,t,s,i,r){return{m_from:e.clone(),m_to:t.clone(),m_next:s,m_type:4,m_center:new o.P}}!function(e){e[e.enumDummy=256]="enumDummy",e[e.enumLine=1]="enumLine",e[e.enumArc=2]="enumArc",e[e.enumMiter=8]="enumMiter",e[e.enumBevel=16]="enumBevel",e[e.enumJoinMask=26]="enumJoinMask",e[e.enumConnectionMask=27]="enumConnectionMask"}(i||(i={}));class y extends r.G{constructor(e,t,s,i,r,n,m,h,l,a){super(),this.m_index=0,this.m_bufferedPolygon=null,this.m_x=0,this.m_y=0,this.m_progressTracker=a,this.m_parent=e,this.m_mp=t,this.m_distance=s,this.m_spatialReference=i,this.m_densifyDist=h,this.m_maxVertexInCompleteCircle=l,this.m_joins=r,this.m_caps=n,this.m_miterLimit=m}next(){let e=new a.P;for(;;){if(this.m_index===this.m_mp.getPointCount())return null;if(1===this.m_caps)return this.m_index=this.m_mp.getPointCount(),new u.a({vd:this.m_mp.getDescription()});if(this.m_mp.getPointByVal(this.m_index,e),this.m_index++,!e.isEmpty())break}let t,s=!1;if(null===this.m_bufferedPolygon&&(this.m_x=e.getX(),this.m_y=e.getY(),this.m_bufferedPolygon=this.m_parent.buffer(e,this.m_distance,this.m_spatialReference,this.m_joins,this.m_caps,this.m_miterLimit,this.m_densifyDist,this.m_maxVertexInCompleteCircle),s=!0),t=this.m_index<this.m_mp.getPointCount()?this.m_bufferedPolygon.clone():this.m_bufferedPolygon,!s){let s=new _.T,i=e.getX()-this.m_x,r=e.getY()-this.m_y;s.setShiftCoords(i,r),t.applyTransformation(s)}return(0,a.s)(t,0),t}getGeometryID(){return 0}getRank(){return 1}tock(){return!0}}class b extends r.G{constructor(e){super(),this.m_currentPathIndex=0,this.m_polyline=e}next(){if(!this.m_polyline)return null;let e=this.m_polyline.getImpl(),t=e.getPathCount();if(this.m_currentPathIndex<t){let t=this.m_currentPathIndex;if(this.m_currentPathIndex++,!e.isClosedPathInXYPlane(t)){let s=e.getXY(e.getPathEnd(t)-1);for(;this.m_currentPathIndex<e.getPathCount();){let t=e.getXY(e.getPathStart(this.m_currentPathIndex));if(e.isClosedPathInXYPlane(this.m_currentPathIndex)||!t.equals(s))break;s=e.getXY(e.getPathEnd(this.m_currentPathIndex)-1),this.m_currentPathIndex++}}if(0===t&&this.m_currentPathIndex===this.m_polyline.getPathCount()){let e=this.m_polyline;return this.m_polyline=null,e}let s=new u.P({vd:this.m_polyline.getDescription()});s.addPath(this.m_polyline,t,!0);for(let i=t+1;i<this.m_currentPathIndex;i++)s.addSegmentsFromPath(this.m_polyline,i,0,e.getSegmentCountPath(i),!1);return this.m_currentPathIndex===this.m_polyline.getPathCount()&&(this.m_polyline=null),s}return null}getGeometryID(){return 0}getRank(){return 1}tock(){return!0}}class x extends r.G{constructor(e,t,s){super(),this.m_geometry=null,this.m_index=0,this.m_bufferer=e,this.m_geoms=t,this.m_index=0,this.m_bFilter=s}next(){if(null===this.m_geometry&&(this.m_index=0,this.m_geometry=this.m_geoms.next(),!this.m_geometry))return null;let e=this.m_geometry.getImpl();if(this.m_index<e.getPathCount()){let e=this.m_index;return this.m_index++,this.m_bufferer.bufferPolylinePath(this.m_geometry,e,this.m_bFilter)}return this.m_geometry=null,this.next()}getGeometryID(){return 0}getRank(){return 1}tock(){return!0}}class C extends r.G{constructor(e){super(),this.m_index=0,this.m_bufferer=e}next(){let e=this.m_bufferer.m_geometry;if(this.m_index<e.getPathCount()){let t=this.m_index,s=e.calculateRingArea2D(this.m_index);for((0,n.g)(s>0),this.m_index++;this.m_index<e.getPathCount()&&!(e.calculateRingArea2D(this.m_index)>0);)this.m_index++;return 0===t&&this.m_index===e.getPathCount()?this.m_bufferer.bufferPolygonImpl(e,0,e.getPathCount()):this.m_bufferer.bufferPolygonImpl(e,t,this.m_index)}return null}getGeometryID(){return 0}getRank(){return 1}tock(){return!0}}class D{constructor(e){this.m_geometry=null,this.m_bufferCommands=[],this.m_originalGeomType=n.G.enumUnknown,this.m_maxVertexInCompleteCircle=-1,this.m_circleTemplateSize=-1,this.m_oldCircleTemplateSize=0,this.m_spatialReference=null,this.m_tolerance=new a.C(0,0),this.m_smallTolerance=new a.C(0,0),this.m_filterTolerance=0,this.m_densifyDist=-1,this.m_distance=Number.NaN,this.m_absDistance=0,this.m_absDistanceReversed=0,this.m_dA=-1,this.m_miterLimit=4,this.m_joins=0,this.m_caps=0,this.m_bRoundBuffer=!0,this.m_bOutputLoops=!0,this.m_bFilter=!0,this.m_circleTemplate=[],this.m_leftStack=[],this.m_middleStack=[],this.m_helperLine1=new u.L,this.m_helperLine2=new u.L,this.m_helperArray=[],this.m_progressCounter=0,this.m_densificator=u.D.constructDefault(e),this.m_progressTracker=e}buffer(e,t,s,i,r,m,l,_){if(e||(0,n.t)("Geometry.Bufferer.Impl.Buffer"),l<0&&(0,n.t)("Geometry.Bufferer.Impl.Buffer"),(0,n.o)(e.getGeometryType())&&(0,n.b)("Unsupported geometry type."),e.isEmpty()||(this.m_joins=i,this.m_caps=r,this.m_bRoundBuffer=!1,this.m_miterLimit=m,this.m_originalGeomType=e.getGeometryType(),(0,n.p)(this.m_originalGeomType)?this.m_bRoundBuffer=0===this.m_joins:(0,n.e)(this.m_originalGeomType)?this.m_bRoundBuffer=0===this.m_caps:(0,n.q)(this.m_originalGeomType)&&(this.m_bRoundBuffer=0===this.m_joins&&0===this.m_caps),this.m_bFilter=this.m_bRoundBuffer,this.m_geometry=(0,c.c)(e),this.m_geometry.isEmpty()))return new u.a({vd:e.getDescription()});let f=new h.J;this.m_geometry.queryLooseEnvelope(f),t>0&&f.inflateCoords(t,t),this.m_tolerance=(0,a.a)(s,f,!0),this.m_smallTolerance=(0,a.a)(null,f,!0),_<=0&&(_=96),this.m_spatialReference=s,this.m_distance=t,this.m_absDistance=Math.abs(this.m_distance),this.m_absDistanceReversed=0!==this.m_absDistance?1/this.m_absDistance:0,Number.isNaN(l)||0===l?l=1e-5*this.m_absDistance:l>.5*this.m_absDistance&&(l=.5*this.m_absDistance),_<12&&(_=12);let g=Math.abs(t)*(1-Math.cos(Math.PI/_));if(g>l)l=g;else if(0!==t){let e=Math.PI/Math.acos(1-l/Math.abs(t));e<_-1&&(_=Math.trunc(e))<12&&(l=Math.abs(t)*(1-Math.cos(Math.PI/(_=12))))}this.m_densifyDist=l,this.m_maxVertexInCompleteCircle=_,this.m_filterTolerance=this.m_bRoundBuffer?Math.min(this.m_smallTolerance.total(),.25*this.m_densifyDist):0,this.m_circleTemplateSize=this.calcN(),this.m_circleTemplateSize!==this.m_oldCircleTemplateSize&&(this.m_circleTemplate.length=0,this.m_oldCircleTemplateSize=this.m_circleTemplateSize),this.m_densifyDist>0&&(0,n.j)(this.m_geometry)&&(this.m_geometry=this.m_densificator.densifyEx(this.m_geometry,0,this.m_densifyDist,0,0!==this.m_joins,(0,o.i)()));let d=this.bufferImpl();return this.m_geometry=null,d}generateCircleTemplate(){if(this.m_circleTemplate.length)return;let e=Math.trunc((this.m_circleTemplateSize+3)/4),t=.5*Math.PI/e;this.m_dA=t,this.m_circleTemplate=(0,o.m)(o.P,4*e);let s=Math.cos(t),i=Math.sin(t),r=o.P.construct(0,1);for(let t=0;t<e;t++)this.m_circleTemplate[t+0*e].setCoords(r.y,-r.x),this.m_circleTemplate[t+ +e].setCoords(-r.x,-r.y),this.m_circleTemplate[t+2*e].setCoords(-r.y,r.x),this.m_circleTemplate[t+3*e].setCoords(r.x,r.y),r.rotateReverse(s,i)}bufferImpl(){let e=this.m_geometry.getGeometryType();if((0,n.f)(e)){let e=new u.P({vd:this.m_geometry.getDescription()});return e.addSegment(this.m_geometry,!0),this.m_geometry=e,this.bufferImpl()}if(this.m_distance<=this.m_tolerance.total()){if(!(0,n.p)(e))return new u.a({vd:this.m_geometry.getDescription()});if(this.m_distance<0){let e=new h.J;if(this.m_geometry.queryEnvelope(e),e.width()<=2*this.m_absDistance||e.height()<=2*this.m_absDistance)return new u.a({vd:this.m_geometry.getDescription()})}}switch(this.m_geometry.getGeometryType()){case n.G.enumPoint:return this.bufferPoint();case n.G.enumMultiPoint:return this.bufferMultiPoint();case n.G.enumPolyline:return this.bufferPolyline();case n.G.enumPolygon:return this.bufferPolygon();case n.G.enumEnvelope:return this.bufferEnvelope();default:(0,n.c)("")}}bufferPolyline(){let e;if(this.isDegenerateGeometry(this.m_geometry)){let e=new a.P;this.m_geometry.getPointByVal(0,e);let t=new h.J;return this.m_geometry.queryEnvelope(t),e.setXY(t.getCenter()),this.bufferDegeneratePath(e,!0)}let t=this.m_geometry,s=this.m_geometry.getDescription();this.m_geometry=null;let i=new b(t);e=0===this.m_joins?(new f.O).executeMany(i,.25*this.m_densifyDist,!1,this.m_progressTracker):i;let r=new x(this,this.m_bRoundBuffer?(new g).executeMany(e,null,!0,this.m_progressTracker):e,this.m_bFilter),n=(new m.h).executeMany(r,this.m_spatialReference,this.m_progressTracker,2),l=(new m.g).executeMany(n,this.m_spatialReference,!1,this.m_progressTracker).next();return null!==l?l:new u.a({vd:s})}bufferPolygon(){if(0===this.m_distance)return this.m_geometry;this.generateCircleTemplate();let e=(new m.g).execute(this.m_geometry,null,!1,this.m_progressTracker);if(this.m_distance<0){if(this.m_geometry=e,this.m_geometry.isEmpty())return this.m_geometry;let t=this.m_geometry,s=this.bufferPolygonImpl(t,0,t.getPathCount());return(new m.g).execute(s,this.m_spatialReference,!1,this.m_progressTracker)}{if(this.m_geometry=e,this.isDegenerateGeometry(this.m_geometry)){let e=new a.P;this.m_geometry.getPointByVal(0,e);let t=new h.J;return this.m_geometry.queryEnvelope(t),e.setXY(t.getCenter()),this.bufferDegeneratePath(e,!0)}let t=new C(this),s=(new m.h).executeMany(t,this.m_spatialReference,this.m_progressTracker,2),i=(new m.g).executeMany(s,this.m_spatialReference,!1,this.m_progressTracker).next();return null!==i?i:new u.a({vd:this.m_geometry.getDescription()})}}bufferPolygonImpl(e,t,s){let i=e.getImpl(),r=new u.a({vd:e.getDescription()});for(let n=t;n<s;n++){if(1>i.getPathSize(n))continue;let t=i.calculateRingArea2D(n),s=new h.J;if(i.queryPathEnvelope(n,s),this.m_distance>0)if(t>0)if(this.isDegeneratePath(i,n)){let e=new a.P;i.getPointByVal(i.getPathStart(n),e),e.setXY(s.getCenter()),r.add(this.bufferDegeneratePath(e,!0),!1)}else{let t=new u.P({vd:e.getDescription()}),s=t.getImpl();if((0,u.i)(this.m_geometry,n)){let t=this.bufferConvexPath(e,n);r.add(t,!1)}else{this.bufferClosedPath(this.m_geometry,n,s,this.m_bRoundBuffer,1);let e=this.bufferCleanup(t);r.add(e,!1)}}else{if(s.width()+this.m_tolerance.total()<=2*this.m_absDistance||s.height()+this.m_tolerance.total()<=2*this.m_absDistance)continue;let t=new u.P({vd:e.getDescription()}),i=t.getImpl();if(this.bufferClosedPath(this.m_geometry,n,i,this.m_bRoundBuffer,1),!t.isEmpty()){let e=Math.max(1,this.m_absDistance),n=s.clone();n.inflateCoords(e,e),i.addEnvelope(n,!1);let m=this.bufferCleanup(t);r.reserve(r.getPointCount()+m.getPointCount()-4),v(m,r,n,!0)}}else if(t>0){if(s.width()+this.m_tolerance.total()<=2*this.m_absDistance||s.height()+this.m_tolerance.total()<=2*this.m_absDistance)continue;let t=new u.P({vd:e.getDescription()}),i=t.getImpl();if(this.bufferClosedPath(this.m_geometry,n,i,this.m_bRoundBuffer,-1),!t.isEmpty()){let e=new h.J;i.queryLooseEnvelope(e);let s=Math.max(1,this.m_absDistance),n=e.clone();n.inflateCoords(s,s),i.addEnvelope(n,!1),v(this.bufferCleanup(t),r,n,!0)}}else{let t=new u.P({vd:e.getDescription()}),s=t.getImpl();this.bufferClosedPath(this.m_geometry,n,s,this.m_bRoundBuffer,-1);let i=this.bufferCleanup(t);for(let e=0,t=i.getPathCount();e<t;e++)r.addPath(i,e,!0)}}if(this.m_distance>0)return r.getPathCount()>1?this.bufferCleanup(r):w(r);{let e=new h.J;if(r.queryLooseEnvelope(e),r.isEmpty())return w(r);{let t=Math.max(1,this.m_absDistance),s=e.clone();s.inflateCoords(t,t),r.addEnvelope(s,!1);let i=this.bufferCleanup(r);r=new u.a;let n=new u.a({vd:i.getDescription()});return v(i,n,s,!1),w(n)}}}bufferPoint(){return this.bufferPointImpl(this.m_geometry)}bufferPointImpl(e){let t=new u.a({vd:e.getDescription()});return 0===this.m_caps?(this.addCircle(t.getImpl(),e),this.setStrongSimple(t)):2===this.m_caps?(this.addSquare(t.getImpl(),e),this.setStrongSimple(t)):t}bufferDegeneratePath(e,t){let s=new u.a({vd:e.getDescription()});return t&&0===this.m_joins||!t&&0===this.m_caps?(this.addCircle(s.getImpl(),e),this.setStrongSimple(s)):t||2!==this.m_caps?s:(this.addSquare(s.getImpl(),e),this.setStrongSimple(s))}bufferMultiPoint(){let e=new y(this,this.m_geometry,this.m_distance,this.m_spatialReference,this.m_joins,this.m_caps,this.m_miterLimit,this.m_densifyDist,this.m_maxVertexInCompleteCircle,this.m_progressTracker);return(new m.h).executeMany(e,this.m_spatialReference,this.m_progressTracker,2).next()}bufferEnvelope(){let e=new u.a({vd:this.m_geometry.getDescription()});if(this.m_distance<=0){if(0===this.m_distance)e.addEnvelope(this.m_geometry,!1),T(this.m_geometry,this.m_tolerance.total())&&(e=this.setStrongSimple(e));else{let t=new a.E;this.m_geometry.queryEnvelope(t),t.inflateCoords(this.m_distance,this.m_distance),e.addEnvelope(t,!1),T(t,this.m_tolerance.total())&&(e=this.setStrongSimple(e))}return e}if(1===this.m_joins){let t=new a.E({copy:this.m_geometry});return t.inflateCoords(this.m_absDistance,this.m_absDistance),e.addEnvelope(t,!1),e}let t=this.m_geometry.clone();if(0===t.width()||0===t.height()){if(0===t.width()&&0===t.height()){let e=new a.P({vd:this.m_geometry.getDescription()});return t.queryCornerByVal(0,e),this.m_geometry=e,this.bufferImpl()}let e=new u.P({vd:this.m_geometry.getDescription()}),s=new a.P;return t.queryCornerByVal(0,s),e.startPathPoint(s),t.queryCornerByVal(2,s),e.lineToPoint(s),this.m_geometry=e,this.bufferImpl()}return e.addEnvelope(this.m_geometry,!1),this.m_geometry=e,this.bufferConvexPath(e,0)}bufferConvexPath(e,t){this.generateCircleTemplate();let s=e.hasAttribute(10),r=new u.a({vd:e.getDescription()}),m=r.getImpl();r.reserve((this.m_circleTemplate.length/10+4)*e.getPathSize(t));let h=new o.P,l=new o.P,a=new o.P,_=new o.P(0,0),c=new o.P,f=new o.P,g=e.getImpl(),d=e.getPathSize(t),p=e.getPathStart(t);for(let r=0,o=e.getPathSize(t);r<o;r++){let e=g.getXY(p+r),t=g.getXY(p+(r+1)%d),o=g.getXY(p+(r+2)%d);c.setSub(t,e),0===c.length()&&(0,n.c)("");let u=s&&!!(1&g.getAttributeAsInt(10,(r+1)%d,0));c.normalize();let P=c.clone();c.leftPerpendicularThis(),c.scale(this.m_absDistance),h.setAdd(c,e),l.setAdd(c,t),0===r?m.startPath(h):m.lineTo(h),m.lineTo(l),f.setSub(o,t),0===f.length()&&(0,n.c)(""),f.normalize();let y=f.clone();f.leftPerpendicularThis(),f.scale(this.m_absDistance),a.setAdd(f,t);let b=i.enumArc,x=u?0:this.m_joins;if(2===x)b=i.enumBevel;else if(1===x){let e=-P.crossProduct(y);_.setSub(P,y),_.scale(this.m_absDistance/e),_.length()<this.m_miterLimit*this.m_absDistance?(_.addThis(t),b=i.enumMiter):b=i.enumBevel}else _.assign(t);this.addJoin(b,m,_,l,a,!1,!1)}return w(r)}bufferPolylinePath(e,t,s){let i;this.generateCircleTemplate();let r=e.getImpl();if(1>r.getPathSize(t))return null;if(i=this.m_bRoundBuffer?r.isClosedPathInXYPlane(t):r.isClosedPath(t),this.isDegeneratePath(r,t)&&this.m_distance>0){let e=new a.P;r.getPointByVal(r.getPathStart(t),e);let s=new h.J;return r.queryPathEnvelope(t,s),e.setXY(s.getCenter()),this.bufferDegeneratePath(e,i)}let n=new u.P({vd:e.getDescription()});n.reserve((Math.trunc(this.m_circleTemplate.length/10)+4)*r.getPathSize(t));let m=n.getImpl();return i?2!==this.bufferClosedPath(e,t,m,s,1)&&this.bufferClosedPath(e,t,m,s,-1):this.bufferOpenPath(e,t,m,s),this.bufferCleanup(n)}progress_(){}bufferCleanup(e,t=!1){let s=t?this.m_tolerance:this.m_smallTolerance;return(0,m.y)(e,s,!0,!t,-1,this.m_progressTracker,0,!1)}calcN(){if(0===this.m_densifyDist)return this.m_maxVertexInCompleteCircle;let e=1-this.m_densifyDist*Math.abs(this.m_absDistanceReversed),t=4;return(t=e<-1?4:2*Math.PI/Math.acos(e)+.5)<4?t=4:t>this.m_maxVertexInCompleteCircle&&(t=this.m_maxVertexInCompleteCircle),Math.trunc(t)}addJoin(e,t,s,r,n,m,h){if(this.generateCircleTemplate(),m&&(t.startPath(r),m=!1),e===i.enumBevel)return void(h&&t.lineTo(n));if(e===i.enumMiter){let e=s.clone();return t.lineTo(e),void(h&&t.lineTo(n))}let l=new o.P;l.setSub(r,s),l.scale(this.m_absDistanceReversed);let a=new o.P;a.setSub(n,s),a.scale(this.m_absDistanceReversed);let u=Math.atan2(l.y,l.x)/this.m_dA;u<0&&(u=this.m_circleTemplate.length+u),u=this.m_circleTemplate.length-u;let _=Math.atan2(a.y,a.x)/this.m_dA;_<0&&(_=this.m_circleTemplate.length+_),(_=this.m_circleTemplate.length-_)<u&&(_+=this.m_circleTemplate.length);let c=Math.trunc(_),f=Math.ceil(u),g=this.m_circleTemplate[f%this.m_circleTemplate.length].clone();g.scaleAddThis(this.m_absDistance,s);let d=10*this.m_tolerance.total();g.sub(r).length()<d&&(f+=1),(g=this.m_circleTemplate[c%this.m_circleTemplate.length].clone()).scaleAddThis(this.m_absDistance,s),g.sub(n).length()<d&&(c-=1);let p=c-f;p++;for(let e=0,i=f%this.m_circleTemplate.length;e<p;e++,i=(i+1)%this.m_circleTemplate.length)(g=this.m_circleTemplate[i].clone()).scaleAddThis(this.m_absDistance,s),t.lineTo(g),this.progress_();h&&t.lineTo(n)}bufferClosedPath(e,t,s,i,r){let n=new u.E,m=n.addPathFromMultiPath(e,t,!0);return this.bufferClosedPathImpl(n,m,s,i,r)}bufferClosedPathImpl(e,t,s,r,m){let h=e.getFirstVertex(e.getFirstPath(t)),c=new a.P;if(e.queryPoint(h,c),e.filterClosePoints(this.m_filterTolerance,!1,!1,!1,-1),2>e.getPointCount(t))return m<0?0:(this.m_bRoundBuffer&&this.addCircle(s,c),2);(0,n.g)(e.getFirstPath(t)!==u.n),(0,n.g)(e.getFirstVertex(e.getFirstPath(t))!==u.n);let f=e.getXY(e.getFirstVertex(e.getFirstPath(t))),g=new _.T;if(g.setShift(f.negate()),e.applyTransformation(g),r){var d,y,b,x,C,D;let i=(d=e,y=t,b=m,x=0,C=this.m_absDistance,D=this.m_filterTolerance,function(e,t,s,i,r,m,h){let a={stack:[],error:void 0,hasError:!1};try{let i=e.getFirstPath(t),_=e.createUserIndex();(0,l.b)(a,(0,o.h)(()=>{e.removeUserIndex(_)},!1),!1),function(e,t,s,i){let r=-1,n=new o.P,m=new o.P,h=new o.P;for(let s=0,l=e.getPathSize(i),a=e.getFirstVertex(i);s<l;++s){-1===r&&(e.queryXY(a,m),-1!==(r=e.getPrevVertex(a))&&(e.queryXY(r,n),h.setSub(m,n),h.normalize()));let s=e.getNextVertex(a);if(-1===s)break;let i=e.getXY(s),l=i.sub(m);l.normalize(),-1!==r&&-.99>l.dotProduct(h)&&1e-7>Math.abs(l.crossProduct(h))&&e.setUserIndex(a,t,1),r=a,a=s,n.assign(m),m.assign(i),h.assign(l)}}(e,_,0,i);for(let t=0;t<100;++t){if(0===e.getPathSize(i))return 1;let t=e.getFirstVertex(i),m=e.getPathSize(i);if(m<3)return 1;e.isClosedPath(i)||(m-=1);let l=0;for(let i=0;i<m&&t!==u.n;i++){let a=0,u=t;for(let l=1,c=Math.min(64,m-i);l<c;l++)if(u=e.getNextVertexEx(u,s),l>1){let i=function(e,t,s,i,r,m,h,l){let a=e.getXY(s),u=e.getXY(i);if(a.equals(u))return -1;let _=.25*h,c=new o.P;c.setSub(u,a);let f=c.length(),g=f*f*.25,d=m*m-g;if(d<=g)return -1;let p=Math.sqrt(d);c.normalize();let P=c.clone();P.rightPerpendicularThis();let y=g/p,b=y<=_,x=o.P.lerp(u,a,.5),C=P.clone();C.scaleAddThis(Math.max(0,y-.25*h),x),P.negate().scaleAddThis(p,x);let D=3.61*(0,o.s)(m-_),w=C.sub(a),T=C.sub(u),v=!1,k=0,S=(0,o.d)(64,0);(0,n.g)(64===S.length);{for(let n=e.getPrevVertexEx(i,r);n!==s;){if(1===e.getUserIndex(n,t))return -1;if(!e.getXY(n).equals(u))break;{let t=e.getPrevVertexEx(n,r);e.removeVertex(n,!1),n=t}}let m=new o.P,h=a.clone();S[k++]=1;for(let n=e.getNextVertexEx(s,r);n!==i;){if(1===e.getUserIndex(n,t))return -1;let s=e.getXY(n);if(s.equals(h)){let t=e.getNextVertexEx(n,r);e.removeVertex(n,!1),n=t;continue}S[k++]=0;let i=new o.P;if(i.setSub(s,a),0>i.dotProduct(P))return 0;(o.P.sqrDistance(s,a)>D||o.P.sqrDistance(s,u)>D)&&(v=!0);let l=0;if(s.sub(a).crossProduct(w)>=0&&(l=1),0>=s.sub(u).crossProduct(T)&&(l|=2),0===l)return 0;S[k-1]=l,m.assign(h),h.assign(s),n=e.getNextVertexEx(n,r)}if(1===k)return 0;(0,n.g)(k<S.length),S[k++]=2}let I=!0;for(let e=1,t=0;e<k;e++)if(S[e]!==S[e-1]&&!(I=++t<3&&(1===t&&3===S[e]||2===t&&2===S[e])))return 0;if(k>2&&I&&(3===k||!v)){let t=0,n=e.getNextVertexEx(s,r);for(b||(e.setXY(n,C),n=e.getNextVertexEx(n,r));n!==i;){let s=e.getNextVertexEx(n,r);e.removeVertex(n,!1),n=s,++t}return t}if((0,n.g)(3!==k),v&&k>3)return 0;let M=a.clone(),G=s,E=a.clone(),R=1,V=-1,A=G,X=0;for(k=1;A!==i;){A=e.getNextVertexEx(A,r);let t=S[k++];if(0===t){if(A===i)break;continue}let s=e.getXY(A);if(-1!==V){if(V&R&t&3){e.removeVertex(G,!0),X++,G=A,E.setCoordsPoint2D(s),R=t;continue}if(3===R&&0!==V&&0!==t){if(E.setCoordsPoint2D(C),b||E.equals(M)){e.removeVertex(G,!0),X++,G=A,E.setCoordsPoint2D(s),R=t;continue}e.setXY(G,E)}}V=R,M.setCoordsPoint2D(E),G=A,R=t,E.setCoordsPoint2D(s)}return X}(e,_,t,u,s,r,h,0);if(-1===i)break;a+=i,m-=i}if(l+=a,a>0){let i=e.getPrevVertexEx(t,s);if(-1!==i){t=i,m++;continue}}t=e.getNextVertexEx(t,s)}if(0===l)break}return e.filterClosePoints(m,!1,!1,!1,-1),1}catch(e){a.error=e,a.hasError=!0}finally{(0,l.c)(a)}}(d,y,b,0,C,D,this.m_densifyDist));if((0,n.g)(1===i),2>e.getPointCount(t))return m<0?0:(this.addCircle(s,c),2)}let w=0!==this.m_joins&&e.getVertexDescription().hasAttribute(10);this.m_bufferCommands.length=0;let T=e.getFirstPath(t),v=e.getFirstVertex(T),k=1===m?e.getPrevVertex(v):e.getNextVertex(v),S=1===m?e.getNextVertex(v):e.getPrevVertex(v),I=!0,M=new o.P,G=new o.P,E=new o.P,R=new o.P,V=new o.P,A=new o.P,X=new o.P,Y=new o.P,B=this.m_absDistance,z=e.getPathSize(T),F=new o.P(0,0);for(let t=0;t<z;t++){G.assign(e.getXY(S)),I&&(M.assign(e.getXY(v)),E.assign(e.getXY(k)),A.setSub(M,E),A.normalize(),Y.leftPerpendicularOther(A),Y.scale(B),R.setAdd(Y,M));let t=w&&!!(1&e.getAttributeAsDbl(10,v,0));V.setSub(G,M),V.normalize(),X.leftPerpendicularOther(V),X.scale(B);let s=new o.P;s.setAdd(M,X);let r=A.crossProduct(V),n=A.dotProduct(V);if(r<0||n<0&&r<Math.abs(n)*Number.EPSILON*8){let e=!1,n=t?0:this.m_joins;if(1===n){let t=-r;F.setSub(A,V),F.scale(this.m_absDistance/t),F.length()<this.m_miterLimit*this.m_absDistance&&(F.addThis(M),e=!0),this.m_bufferCommands.push(p(R,s,F,e?i.enumMiter:i.enumBevel,this.m_bufferCommands.length+1))}else this.m_bufferCommands.push(p(R,s,M,0===n?i.enumArc:i.enumBevel,this.m_bufferCommands.length+1))}else R.equals(s)||(this.m_bufferCommands.push(P(R,M,this.m_bufferCommands.length+1)),this.m_bufferCommands.push(P(M,s,this.m_bufferCommands.length+1)));let h=new o.P;h.setAdd(G,X),this.m_bufferCommands.push(p(s,h,M,i.enumLine,this.m_bufferCommands.length+1)),R.setCoordsPoint2D(h),Y.setCoordsPoint2D(X),E.setCoordsPoint2D(M),M.setCoordsPoint2D(G),A.setCoordsPoint2D(V),k=v,v=S,I=!1,S=1===m?e.getNextVertex(v):e.getPrevVertex(v)}return this.m_bufferCommands.at(-1).m_next=0,this.processBufferCommands(s),g.setShift(f),s.applyTransformationToPath(g,s.getPathCount()-1),1}bufferOpenPath(e,t,s,r){if(this.m_bRoundBuffer){let i=new u.P({vd:e.getDescription()});return i.addPath(e,t,!1),i.addSegmentsFromPath(e,t,0,e.getSegmentCountPath(t),!1),this.bufferClosedPath(i,0,s,r,1)}let m=0,h=new u.P({vd:e.getDescription()}),l=new o.P(0,0);{let i=new u.E,r=i.addPathFromMultiPath(e,t,!1),n=i.getFirstVertex(i.getFirstPath(r)),o=new a.P;if(i.queryPoint(n,o),l.assign(o.getXY()),i.filterClosePoints(0,!1,!1,!1,-1),2>i.getPointCount(r))return this.m_bRoundBuffer&&this.addCircle(s,o),2;let _=i.getGeometry(i.getFirstGeometry());h.addPath(_,0,!1),m=h.getPointCount()-1,h.addSegmentsFromPath(_,0,0,_.getSegmentCountPath(0)-1,!1)}let c=new u.E,f=c.addPathFromMultiPath(h,0,!0);(0,n.g)(c.getFirstPath(f)!==u.n),(0,n.g)(c.getFirstVertex(c.getFirstPath(f))!==u.n);let g=new _.T;g.setShift(l.negate()),c.applyTransformation(g),this.m_bufferCommands.length=0;let d=c.getFirstPath(f),y=0!==this.m_joins&&c.getVertexDescription().hasAttribute(10),b=c.getFirstVertex(d),x=c.getPrevVertex(b),C=c.getNextVertex(b),D=!0,w=new o.P,T=new o.P,v=new o.P,k=new o.P,S=new o.P,I=new o.P,M=new o.P,G=new o.P,E=this.m_absDistance,R=c.getPathSize(d),V=new o.P(0,0);for(let e=0;e<R;e++){let t=!1;0!==e&&e!==m||(t=!0),T.assign(c.getXY(C)),D&&(w.assign(c.getXY(b)),v.assign(c.getXY(x)),I.setSub(w,v),I.normalize(),G.leftPerpendicularOther(I),G.scale(E),k.setAdd(G,w));let s=y&&!!(1&c.getAttributeAsDbl(10,b,0));S.setSub(T,w),S.normalize(),M.leftPerpendicularOther(S),M.scale(E);let r=new o.P;r.setAdd(w,M);let n=I.crossProduct(S),h=I.dotProduct(S);if(n<0||h<0&&n<Math.abs(h)*Number.EPSILON*8)if(t)if(0===this.m_caps)this.m_bufferCommands.push(p(k,r,w,i.enumArc,this.m_bufferCommands.length+1));else if(1===this.m_caps)this.m_bufferCommands.push(p(k,r,w,i.enumLine,this.m_bufferCommands.length+1));else{let e=S.mul(this.m_absDistance).negate(),t=e.clone();e.addThis(k),t.addThis(r),this.m_bufferCommands.push(p(k,e,w,i.enumLine,this.m_bufferCommands.length+1)),this.m_bufferCommands.push(p(e,t,w,i.enumLine,this.m_bufferCommands.length+1)),this.m_bufferCommands.push(p(t,r,w,i.enumLine,this.m_bufferCommands.length+1))}else{let e=!1,t=s?0:this.m_joins;if(1===t){let t=-n;V.setSub(I,S),V.scale(this.m_absDistance/t),V.length()<this.m_miterLimit*this.m_absDistance&&(V.addThis(w),e=!0),this.m_bufferCommands.push(p(k,r,V,e?i.enumMiter:i.enumBevel,this.m_bufferCommands.length+1))}else this.m_bufferCommands.push(p(k,r,w,0===t?i.enumArc:i.enumBevel,this.m_bufferCommands.length+1))}else k.equals(r)||(this.m_bufferCommands.push(P(k,w,this.m_bufferCommands.length+1)),this.m_bufferCommands.push(P(w,r,this.m_bufferCommands.length+1)));let l=new o.P;l.setAdd(T,M),this.m_bufferCommands.push(p(r,l,w,i.enumLine,this.m_bufferCommands.length+1)),k.setCoordsPoint2D(l),G.setCoordsPoint2D(M),v.setCoordsPoint2D(w),w.setCoordsPoint2D(T),I.setCoordsPoint2D(S),x=b,b=C,D=!1,C=c.getNextVertex(b)}return this.m_bufferCommands.at(-1).m_next=0,this.processBufferCommands(s),g.setShift(l),s.applyTransformationToPath(g,s.getPathCount()-1),1}processBufferCommands(e){let t=this.cleanupBufferCommands(),s=!0,r=t+1;for(let n=t;r!==t;n=r){let t=this.m_bufferCommands[n];r=-1!==t.m_next?t.m_next:(n+1)%this.m_bufferCommands.length,t.m_type&&(s&&(e.startPath(t.m_from),s=!1),t.m_type&i.enumJoinMask?this.addJoin(t.m_type,e,t.m_center,t.m_from,t.m_to,!1,!0):e.lineTo(t.m_to))}}cleanupBufferCommands(){this.m_helperArray=(0,o.m)(o.P,9);let e=0;for(let t=0,s=this.m_bufferCommands.length;t<s;){let s=this.m_bufferCommands[t];if(s.m_type&i.enumConnectionMask){e=t;break}t=s.m_next}let t=e+1;for(let s=e;t!==e;s=t){let e=this.m_bufferCommands[s];t=e.m_next;let r=1,n=null;for(;t!==s&&!((n=this.m_bufferCommands[t]).m_type&i.enumConnectionMask);)t=n.m_next,r++;1!==r&&(e.m_type&n.m_type)===i.enumLine&&(this.m_helperLine1.setStartXY(e.m_from),this.m_helperLine1.setEndXY(e.m_to),this.m_helperLine2.setStartXY(n.m_from),this.m_helperLine2.setEndXY(n.m_to),1===this.m_helperLine1.intersect(this.m_helperLine2,this.m_helperArray,null,null,this.m_smallTolerance.total())&&(e.m_to.assign(this.m_helperArray[0]),n.m_from.assign(this.m_helperArray[0]),e.m_next=t))}return e}isDegeneratePath(e,t){if(1===e.getPathSize(t))return!0;if(0===this.m_joins&&0===this.m_caps){let s=new h.J;if(e.queryPathEnvelope(t,s),Math.max(s.width(),s.height())<.5*this.m_densifyDist)return!0}return!1}isDegenerateGeometry(e){if(0===this.m_joins&&0===this.m_caps){let t=new h.J;if(e.queryEnvelope(t),Math.max(t.width(),t.height())<.5*this.m_densifyDist)return!0}return!1}addCircle(e,t){let s=t.getXY();if(0!==this.m_circleTemplate.length){let t=this.m_circleTemplate[0].clone();t.scaleAddThis(this.m_absDistance,s),e.startPath(t);for(let i=1,r=this.m_circleTemplate.length;i<r;i++)(t=this.m_circleTemplate[i].clone()).scaleAddThis(this.m_absDistance,s),e.lineTo(t);return}let i=Math.trunc((this.m_circleTemplateSize+3)/4),r=.5*Math.PI/i;e.reserve(4*i);let n=Math.cos(r),m=Math.sin(r);for(let t=3;t>=0;t--){let r=o.P.construct(0,this.m_absDistance);switch(t){case 0:for(let t=0;t<i;t++)e.lineToCoords(r.x+s.x,r.y+s.y),r.rotateReverse(n,m);break;case 1:for(let t=0;t<i;t++)e.lineToCoords(-r.y+s.x,r.x+s.y),r.rotateReverse(n,m);break;case 2:for(let t=0;t<i;t++)e.lineToCoords(-r.x+s.x,-r.y+s.y),r.rotateReverse(n,m);break;default:e.startPathCoords(r.y+s.x,-r.x+s.y);for(let t=1;t<i;t++)r.rotateReverse(n,m),e.lineToCoords(r.y+s.x,-r.x+s.y)}this.progress_()}}addSquare(e,t){let s=new a.E({vd:t.getDescription()});s.setCoords(t.getX(),t.getY(),t.getX(),t.getY()),s.inflateCoords(this.m_absDistance,this.m_absDistance),e.addEnvelope(s,!1)}setStrongSimple(e){return e.getImpl().setIsSimple(4,this.m_tolerance.total()),e.getImpl().updateOGCFlagsProtected(),e}}function w(e){return(0,a.s)(e,0),e}function T(e,t){return!!e.isEmpty()||Math.min(e.width(),e.height())>t}function v(e,t,s,i){for(let r=0,n=e.getPathCount();r<n;r++){let n=e.getXY(e.getPathStart(r));n.x!==s.xmin&&n.x!==s.xmax&&t.addPath(e,r,i)}}class k{getOperatorType(){return 10004}supportsCurves(){return!0}accelerateGeometry(e,t,s){return!1}canAccelerateGeometry(e){return!1}executeMany(e,t,s,i,r){return this.executeManyEx(e,t,s,Number.NaN,96,i,r)}execute(e,t,s,i){Number.isFinite(s)||(0,n.t)("Invalid distance for buffer operation");let m=new r.S([e]),h=this.executeMany(m,t,[s],!1,i).next();return h||(0,n.c)("null buffer output"),h}executeManyEx(e,t,s,i,r,h,l){if(void 0!==s.find(e=>!Number.isFinite(e))&&(0,n.t)("Invalid distance for buffer operation"),h){let n=new S(e,t,s,i,r,!1,l);return(new m.h).executeMany(n,t,l,2)}return new S(e,t,s,i,r,!1,l)}}class S extends r.G{constructor(e,t,s,i,r,n,m){super(),this.m_currentUnionEnvelope2D=new h.J,this.m_index=-1,this.m_dindex=-1,this.m_progressTracker=m,this.m_bufferer=new D(m),this.m_inputGeoms=e,this.m_spatialReference=t,this.m_distances=s,this.m_maxDeviation=i,this.m_maxVerticesInFullCircle=r}tock(){return!0}getRank(){return 1}next(){{let e;for(;e=this.m_inputGeoms.next();)return(0,n.d)(e),this.m_index=this.m_inputGeoms.getGeometryID(),this.m_dindex+1<this.m_distances.length&&this.m_dindex++,this.buffer(e,this.m_distances[this.m_dindex]);return null}}getGeometryID(){return this.m_index}buffer(e,t){return this.m_bufferer.buffer(e,t,this.m_spatialReference,0,0,4,this.m_maxDeviation,this.m_maxVerticesInFullCircle)}}let I=new k;function M(e,t,s){return I.execute(e,t,s,null)}function G(e,t,s,i,n,m){return Array.from(I.executeManyEx(new r.S(e),t,s,i,n,m,null))}function E(){return I.supportsCurves()}},64601:(e,t,s)=>{s.d(t,{c:()=>r});var i=s(16404);function r(e,t){let s=e.getGeometryType();return s===i.G.enumPoint?e:(0,i.h)(s)?function(e){if(function(e){for(let t=0,s=e.getPathCount();t<s;t++){let s=e.getPathSize(t);if(0===s||1===s&&(0===e.getSegmentCountPath(t)||e.getSegmentType(e.getPathStart(t))===i.G.enumLine||!e.isClosedPath(t)))return!1}return!0}(e))return e;let t=e.createInstance();for(let s=0,r=e.getPathCount();s<r;s++){let r=e.getPathSize(s);if(0!==r){if(1===r&&(0===e.getSegmentCountPath(s)||e.getSegmentType(e.getPathStart(s))===i.G.enumLine||!e.isClosedPath(s)))continue;t.addPath(e,s,!0)}}return t}(e):(s===i.G.enumMultiPoint||s===i.G.enumEnvelope||s===i.G.enumMultipatch&&(0,i.b)("not implemented for multipatch"),e)}},78702:(e,t,s)=>{s.d(t,{O:()=>o});var i=s(81856),r=s(8288),n=s(16404),m=s(32045),h=s(31632),l=s(92656),a=s(99506);class o{getOperatorType(){return 10204}supportsCurves(){return!0}accelerateGeometry(e,t,s){return!1}canAccelerateGeometry(e){return!1}executeMany(e,t,s,i){return new u(e,t,s,i)}execute(e,t,s,i){return e||(0,n.t)("null param is not allowed."),new u(null,t,s,i).generalize(e)}}class u extends r.G{constructor(e,t,s,i){super(),this.m_pline=null,this.m_point=new h.P,this.m_stack=[],this.m_resultstack=[],this.m_callCount=0,this.m_progressTracker=i,this.m_geoms=e,this.m_maxDeviation=t,this.m_bRemoveDegenerateParts=s}tock(){return!0}getRank(){return 1}next(){let e=this.m_geoms.next();return null===e?null:((0,n.d)(e),this.generalize(e))}getGeometryID(){return this.m_geoms.getGeometryID()}generalize(e){let t=e.getGeometryType();if((0,n.e)(t))return e;if(t===n.G.enumEnvelope){let t=new m.a({vd:e.getDescription()});return t.addEnvelope(e,!1),this.generalize(t)}if((0,n.f)(t)){let t=new m.P({vd:e.getDescription()});return t.addSegment(e,!0),this.generalize(t)}if((0,n.h)(t)||(0,n.b)(""),e.isEmpty()||this.m_maxDeviation<=0)return e;let s=(new a.O).execute(e,0,.05*this.m_maxDeviation,0,this.m_progressTracker);e.hasNonLinearSegments()&&(this.m_maxDeviation*=.95);let r=e.createInstance();r.getGeometryType()===n.G.enumPolygon&&r.setFillRule(e.getFillRule()),this.m_xy=s.getAttributeStreamRef(0);{let e={stack:[],error:void 0,hasError:!1};try{let t=new m.L;this.m_pline=t,(0,i.b)(e,(0,l.h)(()=>{this.m_pline=null},!1),!1);for(let e=0,t=s.getPathCount();e<t;e++)this.generalizePath(s.getImpl(),e,r.getImpl())}catch(t){e.error=t,e.hasError=!0}finally{(0,i.c)(e)}}return this.m_resultstack.length=0,this.m_stack.length=0,r}generalizePath(e,t,s){if(2>e.getPathSize(t))return;this.m_resultstack.length=0,this.m_stack.length=0;let i=e.getPathStart(t),r=e.getPathEnd(t)-1,n=e.isClosedPath(t),m=e.isClosedPathInXYPlane(t),h=0,a=-1;this.m_stack.push(n?i:r),this.m_stack.push(i);let o=!1,u=!1;for(!this.m_bRemoveDegenerateParts&&m&&(o=!0,u=!0);this.m_stack.length>1;){let t=this.m_stack.at(-1);this.m_stack.pop();let s=this.m_stack.at(-1),i=e.getXY(t);this.m_pline.setStartXY(i),i=e.getXY(s),this.m_pline.setEndXY(i);let n=[Number.NaN],m=this.findGreatestDistance(t,s,r,n);m>=0&&(o?o=!1:(u&&n[0]>h&&(h=n[0],a=m),n[0]<=this.m_maxDeviation&&(m=-1))),m>=0?(this.m_stack.push(m),this.m_stack.push(t)):this.m_resultstack.push(t)}n||this.m_resultstack.push(this.m_stack[0]);let _=this.m_resultstack.length;if(_===e.getPathSize(t)&&_===this.m_stack.length)s.addPath(e,t,!0);else if(this.m_resultstack.length>0){if(this.m_bRemoveDegenerateParts&&this.m_resultstack.length<=2&&(n||1===this.m_resultstack.length||l.P.distance(e.getXY(this.m_resultstack[0]),e.getXY(this.m_resultstack[1]))<=this.m_maxDeviation))return;if(u&&a>=0&&h<=this.m_maxDeviation){let e=this.m_resultstack.at(-1)>a;this.m_resultstack.push(a),e&&(this.m_resultstack[this.m_resultstack.length-2]=(0,l.b)(this.m_resultstack[this.m_resultstack.length-1],this.m_resultstack[this.m_resultstack.length-1]=this.m_resultstack[this.m_resultstack.length-2]))}for(let t=0,i=this.m_resultstack.length;t<i;t++)e.getPointByVal(this.m_resultstack[t],this.m_point),0===t?s.startPathPoint(this.m_point):s.lineToPoint(this.m_point);if(n){for(let e=this.m_resultstack.length;e<3;e++)s.lineToPoint(this.m_point);s.closePathWithLine()}}}findGreatestDistance(e,t,s,i){let r=t-1;t<=e&&(r=s);let n=-1,m=0,h=new l.P;for(let t=e+1;t<=r;t++){this.m_xy.queryPoint2D(2*t,h);let e=h.x,s=h.y,i=this.m_pline.getClosestCoordinate(h,!1);h.assign(this.m_pline.getCoord2D(i)),h.x-=e,h.y-=s;let r=h.length();r>m&&(n=t,m=r),this.m_callCount++}return i[0]=m,n}}}}]);