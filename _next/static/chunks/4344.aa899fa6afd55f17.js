"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[4344],{34344:(e,n,t)=>{let r;t.r(n),t.d(n,{buffer:()=>z,changeDefaultSpatialReferenceTolerance:()=>Y,clearDefaultSpatialReferenceTolerance:()=>Z,clip:()=>w,contains:()=>m,convexHull:()=>b,crosses:()=>h,cut:()=>d,densify:()=>W,difference:()=>k,disjoint:()=>N,distance:()=>g,equals:()=>S,extendedSpatialReferenceInfo:()=>y,flipHorizontal:()=>q,flipVertical:()=>B,generalize:()=>G,geodesicArea:()=>Q,geodesicBuffer:()=>C,geodesicDensify:()=>F,geodesicLength:()=>U,intersect:()=>L,intersectLinesToPoints:()=>X,intersects:()=>A,isSimple:()=>J,nearestCoordinate:()=>H,nearestVertex:()=>_,nearestVertices:()=>I,offset:()=>V,overlaps:()=>O,planarArea:()=>K,planarLength:()=>M,relate:()=>D,rotate:()=>j,simplify:()=>E,symmetricDifference:()=>v,touches:()=>R,union:()=>T,within:()=>x});var a=t(6675),i=t(39960),c=t(31789);function o(e){return Array.isArray(e)?e[0]?.spatialReference:e?.spatialReference}function u(e){return e?Array.isArray(e)?e.map(u):e.toJSON?e.toJSON():e:e}function s(e){return Array.isArray(e)?e.map(e=>(0,c.rS)(e)):(0,c.rS)(e)}async function f(){return r||(r=(0,a.ho)("geometryEngineWorker",{strategy:"distributed"})),r}async function l(e,n){return(await f()).invoke("executeGEOperation",{operation:e,parameters:u(n)})}async function p(e,n){return Promise.all((await f()).broadcast("executeGEOperation",{operation:e,parameters:u(n)}))}function y(e){return l("extendedSpatialReferenceInfo",[e])}async function w(e,n){return s(await l("clip",[o(e),e,n]))}async function d(e,n){return s(await l("cut",[o(e),e,n]))}function m(e,n){return l("contains",[o(e),e,n])}function h(e,n){return l("crosses",[o(e),e,n])}function g(e,n,t){return l("distance",[o(e),e,n,t])}function S(e,n){return l("equals",[o(e),e,n])}function A(e,n){return l("intersects",[o(e),e,n])}function R(e,n){return l("touches",[o(e),e,n])}function x(e,n){return l("within",[o(e),e,n])}function N(e,n){return l("disjoint",[o(e),e,n])}function O(e,n){return l("overlaps",[o(e),e,n])}function D(e,n,t){return l("relate",[o(e),e,n,t])}function J(e){return l("isSimple",[o(e),e])}async function E(e){return s(await l("simplify",[o(e),e]))}async function b(e,n=!1){return s(await l("convexHull",[o(e),e,n]))}async function k(e,n){return s(await l("difference",[o(e),e,n]))}async function v(e,n){return s(await l("symmetricDifference",[o(e),e,n]))}async function L(e,n){return s(await l("intersect",[o(e),e,n]))}async function T(e,n=null){let t,r=(Array.isArray(e)?t=e:((t=[]).push(e),null!=n&&t.push(n)),t);return s(await l("union",[o(r),r]))}async function V(e,n,t,r,a,i){return s(await l("offset",[o(e),e,n,t,r,a,i]))}async function z(e,n,t,r=!1){let a=[o(e),e,n,t,r];return s(await l("buffer",a))}async function C(e,n,t,r,a,i){let c=[o(e),e,n,t,r,a,i];return s(await l("geodesicBuffer",c))}async function H(e,n,t=!0){let r=await l("nearestCoordinate",[o(e),e,n,t]);return{...r,coordinate:i.A.fromJSON(r.coordinate)}}async function _(e,n){let t=await l("nearestVertex",[o(e),e,n]);return{...t,coordinate:i.A.fromJSON(t.coordinate)}}async function I(e,n,t,r){return(await l("nearestVertices",[o(e),e,n,t,r])).map(e=>({...e,coordinate:i.A.fromJSON(e.coordinate)}))}function P(e){return"xmin"in e?e.center:"x"in e?e:e.extent?.center}async function j(e,n,t){if(null==e)throw new $;let r=e.spatialReference;if(null==(t=t??P(e)))throw new $;let a=e.constructor.fromJSON(await l("rotate",[r,e,n,t]));return a.spatialReference=r,a}async function q(e,n){if(null==e)throw new $;let t=e.spatialReference;if(null==(n=n??P(e)))throw new $;let r=e.constructor.fromJSON(await l("flipHorizontal",[t,e,n]));return r.spatialReference=t,r}async function B(e,n){if(null==e)throw new $;let t=e.spatialReference;if(null==(n=n??P(e)))throw new $;let r=e.constructor.fromJSON(await l("flipVertical",[t,e,n]));return r.spatialReference=t,r}async function G(e,n,t,r){return s(await l("generalize",[o(e),e,n,t,r]))}async function W(e,n,t){return s(await l("densify",[o(e),e,n,t]))}async function F(e,n,t,r=0){return s(await l("geodesicDensify",[o(e),e,n,t,r]))}function K(e,n){return l("planarArea",[o(e),e,n])}function M(e,n){return l("planarLength",[o(e),e,n])}function Q(e,n,t){return l("geodesicArea",[o(e),e,n,t])}function U(e,n,t){return l("geodesicLength",[o(e),e,n,t])}async function X(e,n){return s(await l("intersectLinesToPoints",[o(e),e,n]))}async function Y(e,n){await p("changeDefaultSpatialReferenceTolerance",[e,n])}async function Z(e){await p("clearDefaultSpatialReferenceTolerance",[e])}class $ extends Error{constructor(){super("Illegal Argument Exception")}}}}]);