"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[5794],{5794:(e,t,l)=>{l.d(t,{ElevationQuery:()=>E});var i=l(83610),a=l(32391),n=l(40941),s=l(92753),o=l(8922),r=l(147),u=l(39960),h=l(65442),c=l(65111),p=l(84766);l(57845);var f=l(19158),m=l(61939),d=l(6322);let y=()=>m.A.getLogger("esri.layers.support.ElevationSampler");class x{queryElevation(e){return function(e,t){let l=T(e,t.spatialReference);if(!l)return null;switch(e.type){case"point":var i,a;i=e,a=l,i.z=t.elevationAt(a.x,a.y);break;case"polyline":!function(e,t,l){g.spatialReference=t.spatialReference;let i=e.hasM&&!e.hasZ;for(let a=0;a<e.paths.length;a++){let n=e.paths[a],s=t.paths[a];for(let e=0;e<n.length;e++){let t=n[e],a=s[e];g.x=a[0],g.y=a[1],i&&(t[3]=t[2]),t[2]=l.elevationAt(g.x,g.y)}}e.hasZ=!0}(e,l,t);break;case"multipoint":var n=e,s=l,o=t;g.spatialReference=s.spatialReference;let r=n.hasM&&!n.hasZ;for(let e=0;e<n.points.length;e++){let t=n.points[e],l=s.points[e];g.x=l[0],g.y=l[1],r&&(t[3]=t[2]),t[2]=o.elevationAt(g.x,g.y)}n.hasZ=!0}return e}(e.clone(),this)}on(){return(0,f.hA)()}projectIfRequired(e,t){return T(e,t)}}class v extends x{get spatialReference(){return this.extent.spatialReference}constructor(e,t,l){super(),this.tile=e,this.noDataValue=l;let i=e.tile.extent;this.extent=(0,p.w1)(i,t.spatialReference),this.extent.zmin=e.zmin,this.extent.zmax=e.zmax,this._aaExtent=i;let a=(0,o.GA)(t.spatialReference),n=t.lodAt(e.tile.level).resolution*a;this.demResolution={min:n,max:n}}contains(e){let t=this.projectIfRequired(e,this.spatialReference);return null!=t&&this.containsAt(t.x,t.y)}containsAt(e,t){return(0,p.Rj)(this._aaExtent,e,t)}elevationAt(e,t){if(!this.containsAt(e,t)){let l=this.extent,i=`${l.xmin}, ${l.ymin}, ${l.xmax}, ${l.ymax}`;return y().warn("#elevationAt()",`Point used to sample elevation (${e}, ${t}) is outside of the sampler extent (${i})`),this.noDataValue}return this.tile.sample(e,t)??this.noDataValue}}class w extends x{get spatialReference(){return this.extent.spatialReference}constructor(e,t,l){let i;super(),"number"==typeof t?(this.noDataValue=t,i=null):(i=t,this.noDataValue=l),this.samplers=i?e.map(e=>new v(e,i,this.noDataValue)):e;let a=this.samplers[0];if(a){this.extent=a.extent.clone();let{min:e,max:t}=a.demResolution;this.demResolution={min:e,max:t};for(let e=1;e<this.samplers.length;e++){let t=this.samplers[e];this.extent.union(t.extent),this.demResolution.min=Math.min(this.demResolution.min,t.demResolution.min),this.demResolution.max=Math.max(this.demResolution.max,t.demResolution.max)}}else this.extent=(0,p.w1)((0,p.vt)(),i.spatialReference),this.demResolution={min:0,max:0}}elevationAt(e,t){let l,i=!1;for(let a of this.samplers)if(a.containsAt(e,t)&&(i=!0,(l=a.elevationAt(e,t))!==a.noDataValue))return l;return null!=l?l:(i||y().warn("#elevationAt()",`Point used to sample elevation (${e}, ${t}) is outside of the sampler`),this.noDataValue)}}function T(e,t){if(null==e)return null;let l=e.spatialReference;if(l.equals(t))return e;let i=(0,d.Cv)(e,t);return i||y().error(`Cannot project geometry spatial reference (wkid:${l.wkid}) to elevation sampler spatial reference (wkid:${t.wkid})`),i}let g=new u.A;class _{constructor(e,t){this.data=e,this.safeWidth=.99999999*(e.width-1),this.dx=(e.width-1)/(t[2]-t[0]),this.dy=(e.width-1)/(t[3]-t[1]),this.x0=t[0],this.y1=t[3]}}class A{constructor(e,t=null){if(this.tile=e,null!=t&&null!=e){let l=e.extent;this._samplerData=new _(t,l)}}get zmin(){return null!=this._samplerData?this._samplerData.data.minValue:0}get zmax(){return null!=this._samplerData?this._samplerData.data.maxValue:0}get hasNoDataValues(){return!!this._samplerData?.data.hasNoDataValues}sample(e,t){var l,i,a,n,s,o;if(null==this._samplerData)return;let{safeWidth:r,data:u,dx:h,dy:c,y1:p,x0:f}=this._samplerData,{width:m,values:d,noDataValue:y}=u,x=(l=c*(p-t),i=0,a=r,l<0?i:l>a?a:l),v=(n=h*(e-f),s=0,o=r,n<0?s:n>o?o:n),w=Math.floor(x),T=Math.floor(v),g=w*m+T,_=g+m,A=d[g],R=d[_],E=d[g+1],q=d[_+1];if(A!==y&&R!==y&&E!==y&&q!==y){let e=v-T,t=A+(E-A)*e;return t+(R+(q-R)*e-t)*(x-w)}}}var R=l(99047);class E{async queryAll(e,t,l){if(!(e=l?.ignoreInvisibleLayers?e.filter(e=>e.visible):e.slice()).length)throw new a.A("elevation-query:invalid-layer","Elevation queries require at least one elevation layer to fetch tiles from");let i=q.fromGeometry(t),n=!1;l?.returnSampleInfo||(n=!0);let s={...V,...l,returnSampleInfo:!0},o=await this.query(e[e.length-1],i,s),r=await this._queryAllContinue(e,o,s);return r.geometry=r.geometry.export(),n&&delete r.sampleInfo,r}async query(e,t,l){var i;if(!e)throw new a.A("elevation-query:invalid-layer","Elevation queries require an elevation layer to fetch tiles from");if(!t||!(t instanceof q)&&"point"!==t.type&&"multipoint"!==t.type&&"polyline"!==t.type)throw new a.A("elevation-query:invalid-geometry","Only point, polyline and multipoint geometries can be used to query elevation");let n={...V,...l},s=new C(e,t.spatialReference,n),o=n.signal;return await e.load({signal:o}),await k(s,t,o),await this._selectTiles(s,o),await b(s,o),(i=s).geometry.coordinates.forEach(e=>{let t=e.elevationTile,l=i.options.noDataValue;if(t){let i=t.sample(e.x,e.y);null!=i?l=i:e.elevationTile=null}e.z=l}),$(s,o)}async createSampler(e,t,l){if(!e)throw new a.A("elevation-query:invalid-layer","Elevation queries require an elevation layer to fetch tiles from");if(!t||"extent"!==t.type)throw new a.A("elevation-query:invalid-extent","Invalid or undefined extent");let i={...V,...l};return this._createSampler(e,t,i)}async createSamplerAll(e,t,l){if(!(e=l?.ignoreInvisibleLayers?e.filter(e=>e.visible):e.slice()).length)throw new a.A("elevation-query:invalid-layer","Elevation queries require at least one elevation layer to fetch tiles from");if(!t||"extent"!==t.type)throw new a.A("elevation-query:invalid-extent","Invalid or undefined extent");let i={...V,...l,returnSampleInfo:!0},n=await this._createSampler(e[e.length-1],t,i);return this._createSamplerAllContinue(e,t,n,i)}async _createSampler(e,t,l,i){let a=l.signal;await e.load({signal:a});let n=t.spatialReference,s=e.tileInfo.spatialReference;n.equals(s)||(await (0,c.initializeProjection)([{source:n,dest:s}],{signal:a}),t=(0,c.project)(t,s));let o=new z(e,t,l,i);return await this._selectTiles(o,a),await b(o,a),new w(o.elevationTiles,o.layer.tileInfo,o.options.noDataValue)}async _createSamplerAllContinue(e,t,l,i){if(e.pop(),!e.length)return l;let a=l.samplers.filter(e=>!e.tile.hasNoDataValues).map(e=>(0,p.VY)(e.extent)),n=await this._createSampler(e[e.length-1],t,i,a);if(0===n.samplers.length)return l;let s=new w(l.samplers.concat(n.samplers),i.noDataValue);return this._createSamplerAllContinue(e,t,s,i)}async _queryAllContinue(e,t,l){let i=e.pop(),a=t.geometry.coordinates,s=t.sampleInfo;(0,n.Lw)(s);let o=[],r=[];for(let t=0;t<a.length;t++){let l=s[t];l.demResolution>=0?l.source||(l.source=i):e.length&&(o.push(a[t]),r.push(t))}if(!e.length||0===o.length)return t;let u=t.geometry.clone(o),h=await this.query(e[e.length-1],u,l),c=h.sampleInfo;if(!c)throw Error("no sampleInfo");return r.forEach((e,t)=>{a[e].z=h.geometry.coordinates[t].z,s[e].demResolution=c[t].demResolution}),this._queryAllContinue(e,t,l)}async _selectTiles(e,t){"geometry"===e.type&&function(e){if(null==e.layer.fullExtent)return;let t=new A(null);t.sample=()=>e.options.noDataValue,e.outsideExtentTile=t;let l=e.layer.fullExtent;e.geometry.coordinates.forEach(e=>{let i=e.x,a=e.y;(i<l.xmin||i>l.xmax||a<l.ymin||a>l.ymax)&&(e.elevationTile=t)})}(e);let l=e.options.demResolution;if("number"==typeof l){var i=e,n=l;let t=function(e,t){let{tileInfo:l,tilemapCache:i}=e.layer,a=t/(0,o.GA)(l.spatialReference),n=F(l,i),s=n[0],r=0;for(let e=1;e<n.length;e++){let t=n[e];Math.abs(t.resolution-a)<Math.abs(s.resolution-a)&&(s=t,r=e)}return r}(i,n);i.selectTilesAtLOD(t)}else if("finest-contiguous"===l)await this._selectTilesFinestContiguous(e,t);else{if("auto"!==l)throw new a.A("elevation-query:invalid-dem-resolution",`Invalid dem resolution value '${l}', expected a number, "finest-contiguous" or "auto"`);await this._selectTilesAuto(e,t)}}async _selectTilesFinestContiguous(e,t){let{tileInfo:l,tilemapCache:i}=e.layer,a=M(l,i,e.options.minDemResolution);await this._selectTilesFinestContiguousAt(e,a,t)}async _selectTilesFinestContiguousAt(e,t,l){let i=e.layer;if(e.selectTilesAtLOD(t),t<0)return;let n=i.tilemapCache,o=e.getTilesToFetch();try{if(n&&!L(n))await (0,s.qr)(Promise.all(o.map(e=>n.fetchAvailability(e.level,e.row,e.col,{signal:l}))),l);else if(await b(e,l),!e.allElevationTilesFetched())throw e.clearElevationTiles(),new a.A("elevation-query:has-unavailable-tiles")}catch(i){(0,s.QP)(i),await this._selectTilesFinestContiguousAt(e,t-1,l)}}async _selectTilesAuto(e,t){(function(e){let{tileInfo:t,tilemapCache:l}=e.layer,i=M(t,l,e.options.minDemResolution);e.selectTilesAtLOD(i,e.options.maximumAutoTileRequests)})(e),function(e){let t=e.layer.tileInfo,l=0,i={},a=e=>{null!=e.id&&(e.id in i?i[e.id]++:(i[e.id]=1,l++))},n=e=>{if(null==e.id)return;let t=i[e.id];1===t?(delete i[e.id],l--):i[e.id]=t-1};e.forEachTileToFetch(a,n);let s=!0;for(;s&&(s=!1,e.forEachTileToFetch(i=>{l<=e.options.maximumAutoTileRequests||(n(i),t.upsampleTile(i)&&(s=!0),a(i))},n),s););}(e);let l=e.layer.tilemapCache;if(!l||L(l))return this._selectTilesAutoPrefetchUpsample(e,t);let a=e.getTilesToFetch(),n={},o=a.map(async e=>{let a=new R.U(null,0,0,0,(0,p.vt)()),o=await (0,i.Ke)(l.fetchAvailabilityUpsample(e.level,e.row,e.col,a,{signal:t}));!1!==o.ok?null!=e.id&&(n[e.id]=a):(0,s.QP)(o.error)});await (0,s.qr)(Promise.all(o),t),e.remapTiles(n)}async _selectTilesAutoPrefetchUpsample(e,t){let l=e.layer.tileInfo;await b(e,t);let i=!1;e.forEachTileToFetch((e,t)=>{l.upsampleTile(e)?i=!0:t()}),i&&await this._selectTilesAutoPrefetchUpsample(e,t)}}class q{export(){return this._exporter(this.coordinates,this.spatialReference)}clone(e){let t=new q;return t.geometry=this.geometry,t.spatialReference=this.spatialReference,t.coordinates=e||this.coordinates.map(e=>e.clone()),t._exporter=this._exporter,t}async project(e,t){if(this.spatialReference.equals(e))return this.clone();await (0,c.initializeProjection)([{source:this.spatialReference,dest:e}],{signal:t});let l=new r.A({spatialReference:this.spatialReference,points:this.coordinates.map(e=>[e.x,e.y])}),i=(0,c.project)(l,e);if(!i)return null;let a=this.coordinates.map((e,t)=>{let l=e.clone(),a=i.points[t];return l.x=a[0],l.y=a[1],l}),n=this.clone(a);return n.spatialReference=e,n}static fromGeometry(e){let t=new q;if(t.geometry=e,t.spatialReference=e.spatialReference,e instanceof q)t.coordinates=e.coordinates.map(e=>e.clone()),t._exporter=(t,l)=>{let i=e.clone(t);return i.spatialReference=l,i};else switch(e.type){case"point":{let{hasZ:l,hasM:i}=e;t.coordinates=l&&i?[new D(e.x,e.y,e.z,e.m)]:l?[new D(e.x,e.y,e.z)]:i?[new D(e.x,e.y,null,e.m)]:[new D(e.x,e.y)],t._exporter=(t,l)=>e.hasM?new u.A(t[0].x,t[0].y,t[0].z,t[0].m,l):new u.A(t[0].x,t[0].y,t[0].z,l);break}case"multipoint":{let{hasZ:l,hasM:i}=e;t.coordinates=l&&i?e.points.map(e=>new D(e[0],e[1],e[2],e[3])):l?e.points.map(e=>new D(e[0],e[1],e[2])):i?e.points.map(e=>new D(e[0],e[1],null,e[2])):e.points.map(e=>new D(e[0],e[1])),t._exporter=(t,l)=>e.hasM?new r.A({points:t.map(e=>[e.x,e.y,e.z,e.m]),hasZ:!0,hasM:!0,spatialReference:l}):new r.A(t.map(e=>[e.x,e.y,e.z]),l);break}case"polyline":{let l=[],i=[],{hasZ:a,hasM:n}=e,s=0;for(let t of e.paths)if(i.push([s,s+t.length]),s+=t.length,a&&n)for(let e of t)l.push(new D(e[0],e[1],e[2],e[3]));else if(a)for(let e of t)l.push(new D(e[0],e[1],e[2]));else if(n)for(let e of t)l.push(new D(e[0],e[1],null,e[2]));else for(let e of t)l.push(new D(e[0],e[1]));t.coordinates=l,t._exporter=(t,l)=>{let a=e.hasM?t.map(e=>[e.x,e.y,e.z??0,e.m??0]):t.map(e=>[e.x,e.y,e.z??0]),n=i.map(e=>a.slice(e[0],e[1]));return new h.A({paths:n,hasM:e.hasM,hasZ:!0,spatialReference:l})}}}return t}}class D{constructor(e,t,l=null,i=null,a=null,n=null){this.x=e,this.y=t,this.z=l,this.m=i,this.tile=a,this.elevationTile=n}clone(){return new D(this.x,this.y,this.z,this.m)}}class I{constructor(e,t){this.layer=e,this.options=t}}class C extends I{constructor(e,t,l){super(e,l),this.outSpatialReference=t,this.type="geometry"}selectTilesAtLOD(e){if(e<0)this.geometry.coordinates.forEach(e=>e.tile=null);else{let{tileInfo:t,tilemapCache:l}=this.layer,i=F(t,l)[e].level;this.geometry.coordinates.forEach(e=>e.tile=t.tileAt(i,e.x,e.y))}}allElevationTilesFetched(){return!this.geometry.coordinates.some(e=>!e.elevationTile)}clearElevationTiles(){for(let e of this.geometry.coordinates)e.elevationTile!==this.outsideExtentTile&&(e.elevationTile=null)}populateElevationTiles(e){for(let t of this.geometry.coordinates)!t.elevationTile&&t.tile?.id&&(t.elevationTile=e[t.tile.id])}remapTiles(e){for(let t of this.geometry.coordinates){let l=t.tile?.id;t.tile=l?e[l]:null}}getTilesToFetch(){let e={},t=[];for(let l of this.geometry.coordinates){let i=l.tile;if(!i)continue;let a=l.tile?.id;l.elevationTile||!a||e[a]||(e[a]=i,t.push(i))}return t}forEachTileToFetch(e){for(let t of this.geometry.coordinates)t.tile&&!t.elevationTile&&e(t.tile,()=>{t.tile=null})}}class z extends I{constructor(e,t,l,i){super(e,l),this.type="extent",this.elevationTiles=[],this._candidateTiles=[],this._fetchedCandidates=new Set,this.extent=t.clone().intersection(e.fullExtent),this.maskExtents=i}selectTilesAtLOD(e,t){let l=Math.min(this._maximumLodForRequests(t),e);l<0?this._candidateTiles.length=0:this._selectCandidateTilesCoveringExtentAt(l)}_maximumLodForRequests(e){let{tileInfo:t,tilemapCache:l}=this.layer,i=F(t,l);if(!e)return i.length-1;let a=this.extent;if(null==a)return -1;for(let l=i.length-1;l>=0;l--){let n=i[l],s=n.resolution*t.size[0],o=n.resolution*t.size[1];if(Math.ceil(a.width/s)*Math.ceil(a.height/o)<=e)return l}return -1}allElevationTilesFetched(){return this._candidateTiles.length===this.elevationTiles.length}clearElevationTiles(){this.elevationTiles.length=0,this._fetchedCandidates.clear()}populateElevationTiles(e){for(let t of this._candidateTiles){let l=t.id&&e[t.id];l&&(this._fetchedCandidates.add(t),this.elevationTiles.push(l))}}remapTiles(e){this._candidateTiles=S(this._candidateTiles.map(t=>e[t.id]))}getTilesToFetch(){return this._candidateTiles}forEachTileToFetch(e,t){let l=this._candidateTiles;this._candidateTiles=[],l.forEach(l=>{if(this._fetchedCandidates.has(l))return void(t&&t(l));let i=!1;e(l,()=>i=!0),i?t&&t(l):this._candidateTiles.push(l)}),this._candidateTiles=S(this._candidateTiles,t)}_selectCandidateTilesCoveringExtentAt(e){this._candidateTiles.length=0;let t=this.extent;if(null==t)return;let{tileInfo:l,tilemapCache:i}=this.layer,a=F(l,i)[e],n=l.tileAt(a.level,t.xmin,t.ymin),s=n.extent;if(null==s)return;let o=a.resolution*l.size[0],r=a.resolution*l.size[1],u=Math.ceil((t.xmax-s[0])/o),h=Math.ceil((t.ymax-s[1])/r);for(let e=0;e<h;e++)for(let t=0;t<u;t++){let i=new R.U(null,n.level,n.row-e,n.col+t);l.updateTileInfo(i),this._tileIsMasked(i)||this._candidateTiles.push(i)}}_tileIsMasked(e){return!!this.maskExtents&&this.maskExtents.some(t=>e.extent&&(0,p.gR)(t,e.extent))}}function M(e,t,l=0){let i=F(e,t),a=i.length-1;if(l>0){let t=l/(0,o.GA)(e.spatialReference),n=i.findIndex(e=>e.resolution<t);0===n?a=0:n>0&&(a=n-1)}return a}let V={maximumAutoTileRequests:20,noDataValue:0,returnSampleInfo:!1,demResolution:"auto",minDemResolution:0};async function k(e,t,l){let i,n=e.layer.tileInfo.spatialReference;if(t instanceof q?i=await t.project(n,l):(await (0,c.initializeProjection)([{source:t.spatialReference,dest:n}],{signal:l}),i=(0,c.project)(t,n)),!i)throw new a.A("elevation-query:spatial-reference-mismatch",`Cannot query elevation in '${t.spatialReference.wkid}' on an elevation service in '${n.wkid}'`);e.geometry=q.fromGeometry(i)}function F(e,t){let l=e.lods;if(L(t)){let{effectiveMinLOD:e,effectiveMaxLOD:i}=t;return l.filter(t=>t.level>=e&&t.level<=i)}return l}async function b(e,t){let l=e.getTilesToFetch(),i={},a=e.options.cache,n=e.options.noDataValue,o=l.map(async l=>{if(null==l.id)return;let s=`${e.layer.uid}:${l.id}:${n}`,o=null!=a?a.get(s):null,r=null!=o?o:await e.layer.fetchTile(l.level,l.row,l.col,{noDataValue:n,signal:t});null!=a&&a.put(s,r),i[l.id]=new A(l,r)});await (0,s.qr)(Promise.allSettled(o),t),e.populateElevationTiles(i)}function S(e,t){let l={},i=[];for(let a of e){let e=a.id;e&&!l[e]?(l[e]=a,i.push(a)):t&&t(a)}let a=i.sort((e,t)=>e.level-t.level);return a.filter((e,l)=>{for(let i=0;i<l;i++){let l=a[i].extent;if(l&&e.extent&&(0,p.gR)(l,e.extent))return t&&t(e),!1}return!0})}async function $(e,t){let l=await e.geometry.project(e.outSpatialReference,t);(0,n.Lw)(l);let i={geometry:l.export(),noDataValue:e.options.noDataValue};return e.options.returnSampleInfo&&(i.sampleInfo=function(e){let t=e.layer.tileInfo,l=(0,o.GA)(t.spatialReference);return e.geometry.coordinates.map(i=>{let a=-1;return i.elevationTile&&i.elevationTile!==e.outsideExtentTile&&(a=t.lodAt(i.elevationTile.tile.level).resolution*l),{demResolution:a}})}(e)),e.geometry.coordinates.forEach(e=>{e.tile=null,e.elevationTile=null}),i}function L(e){return null!=e?.tileInfo}}}]);